/* Josip Medved <jmedved@jmedved.com> * www.medo64.com * MIT License */

namespace Medo;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;

#if NET6_0_OR_GREATER
using System.Diagnostics.CodeAnalysis;
#endif

#if NET7_0_OR_GREATER
using System.Runtime.Intrinsics;
#endif


/// <summary>
/// Implements UUID version 7 as defined in RFC draft at
/// https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html.
/// </summary>
[DebuggerDisplay("{ToString(),nq}")]
[StructLayout(LayoutKind.Sequential)]
public readonly partial struct Uuid7 {

    /// <summary>
    /// Creates a new version 7 UUID.
    /// Sequencing is done on a per-thread basis. This means that each thread
    /// maintains a separate counter, and thus sequences generated by different
    /// threads might overlap. Please note that this overlap is no  worse than
    /// what one would expect if the code was executing on a different computer.
    /// However, if strict sequencing is required, please use the static
    /// NewUuid7() method that guarantees this behavior.
    /// </summary>
    public Uuid7() {
        Bytes = new byte[16];
        FillBytes7(ref Bytes, DateTime.UtcNow.Ticks, ref PerThreadLastMillisecond, ref PerThreadMillisecondCounter, ref PerThreadMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
    }

    /// <summary>
    /// Creates a new instance from given byte array.
    /// No check if array is version 7 UUID is made.
    /// </summary>
    /// <exception cref="ArgumentNullException">Buffer cannot be null.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Buffer must be exactly 16 bytes in length.</exception>
    public Uuid7(byte[] buffer) {
        if (buffer == null) { throw new ArgumentNullException(nameof(buffer), "Buffer cannot be null."); }
        if (buffer.Length != 16) { throw new ArgumentOutOfRangeException(nameof(buffer), "Buffer must be exactly 16 bytes in length."); }
        Bytes = new byte[16];
        Buffer.BlockCopy(buffer, 0, Bytes, 0, 16);
    }

#if NET6_0_OR_GREATER
    /// <summary>
    /// Creates a new instance from given read-only byte span.
    /// No check if array is version 7 UUID is made.
    /// </summary>
    /// <exception cref="ArgumentNullException">Span cannot be null.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Span must be exactly 16 bytes in length.</exception>
    public Uuid7(ReadOnlySpan<byte> span) {
        if (span.Length != 16) { throw new ArgumentOutOfRangeException(nameof(span), "Span must be exactly 16 bytes in length."); }
        Bytes = new byte[16];
        span.CopyTo(Bytes);
    }
#endif

    /// <summary>
    /// Creates a new instance from given GUID bytes.
    /// No check if GUID is version 7 UUID is made.
    /// </summary>
    /// <param name="guid">Guid.</param>
    public Uuid7(Guid guid)
        : this(guid, bigEndian: IsBigEndian) {
    }

    /// <summary>
    /// Creates a new instance from given GUID bytes.
    /// No check if GUID is version 7 UUID is made.
    /// </summary>
    /// <param name="guid">Guid.</param>
    /// <param name="bigEndian">If true, input will be assumed to be in a big-endian format.</param>
    public Uuid7(Guid guid, bool bigEndian) {
        if (IsBigEndian != bigEndian) {
            Bytes = guid.ToByteArray();
        } else {
            Bytes = ReverseGuidEndianess(guid.ToByteArray());
        }
    }


    /// <summary>
    /// Creates a new instance with a given byte array.
    /// No check if array is version 7 UUID is made.
    /// No check for array length is made.
    /// </summary>
    private Uuid7(ref byte[] buffer) {
        Bytes = buffer;
    }

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
    private readonly byte[] Bytes;


    /// <summary>
    /// Gets the value of the version field.
    /// </summary>
    public int Version {
        get {
            if (Bytes == null) { return 0; }
            return (Bytes[6] & 0xF0) >> 4;
        }
    }

    /// <summary>
    /// Gets the value of the variant field.
    /// Please note the variant returned is 4-bit value as defined in RFC9562,
    /// section 4.1. In practice, this means that version 7 values can have values
    /// 8-11 (8-B, in hexadecimal).
    /// </summary>
    public int Variant {
        get {
            if (Bytes == null) { return 0; }
            return Bytes[8] >> 4;
        }
    }


    #region Static

    /// <summary>
    /// A read-only instance of the Uuid7 structure whose value is all zeros.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 MinValue = new(new byte[16]);

    /// <summary>
    /// A read-only instance of the Uuid7 structure whose value is all ones.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 MaxValue = new([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);

    /// <summary>
    /// A read-only instance of the Uuid7 structure whose value is all zeros.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 Empty = MinValue;

    /// <summary>
    /// A read-only instance of the Uuid7 structure whose value is all ones.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 AllBitsSet = MaxValue;


    /// <summary>
    /// Returns a new UUID version 7.
    /// This method is thread-safe.
    /// For higher multi-threaded performance, consider using new Uuid7()
    /// instead, as it utilizes per-thread counters. While this doesn't
    /// guarantee strict sequencing, it provides no worse results than
    /// generating UUIDs on multiple computers.
    /// </summary>
    public static Uuid7 NewUuid7() {
        var bytes = new byte[16];
        lock (NonThreadedSyncRoot) {
            FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
        }
        return new Uuid7(ref bytes);
    }

    /// <summary>
    /// Returns a new UUID version 7 with a specific timestamp.
    /// This is not recommended for general use since it doesn't offer the same collision protections as the default NewUuid7() method.
    /// This method is thread-safe.
    /// </summary>
    public static Uuid7 NewUuid7(DateTimeOffset timestamp) {
        var bytes = new byte[16];
        long lastMillisecond = 0;
        long millisecondCounter = 0;
        uint monotonicCounter = 0;
        FillBytes7(ref bytes, timestamp.UtcTicks, ref lastMillisecond, ref millisecondCounter, ref monotonicCounter);
        return new Uuid7(ref bytes);
    }

    /// <summary>
    /// Returns new UUID version 4.
    /// This method is thread-safe.
    /// </summary>
    public static Uuid7 NewUuid4() {
        var bytes = new byte[16];
        FillBytes4(ref bytes);
        return new Uuid7(ref bytes);
    }

    /// <summary>
    /// Returns an equivalent System.Guid of a UUID version 7.
    /// This method is thread-safe.
    /// </summary>
    public static Guid NewGuid() {
        return NewGuid(bigEndian: IsBigEndian);
    }

    /// <summary>
    /// Returns an equivalent System.Guid of a UUID version 7.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="bigEndian">If true, input will be assumed to be in a big-endian format.</param>
    public static Guid NewGuid(bool bigEndian) {
        var bytes = new byte[16];
        lock (NonThreadedSyncRoot) {
            FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
        }
        if (IsBigEndian == bigEndian) { ReverseGuidEndianess(ref bytes); }
        return new Guid(bytes);
    }


    /// <summary>
    /// Returns a System.Guid of a UUID version 7 suitable for insertion into a
    /// Microsoft SQL database. This should be used only when working with MS
    /// SQL Server and not with any other databases as byte ordering is
    /// different than usual. If you are using Uuid7 in a mixed database
    /// environment, use the NewUuid7() method instead.
    /// This method is thread-safe.
    /// </summary>
    public static Guid NewMsSqlUniqueIdentifier() {
        var bytes = new byte[16];
        lock (NonThreadedSyncRoot) {
            FillBytes7MsSql(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
        }
        return new Guid(bytes);
    }


    /// <summary>
    /// Fills a span with version 7 UUIDs.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void Fill(Span<Uuid7> data) {
#else
    public static void Fill(Uuid7[] data) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                data[i] = new Uuid7(ref bytes);
            }
        }
    }

    /// <summary>
    /// Fills a span with version 7 UUIDs.
    /// All UUIDs are created with the same timestamp.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <param name="timestamp">Millisecond time for when UUIDs are to be created.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void Fill(Span<Uuid7> data, DateTimeOffset timestamp) {
#else
    public static void Fill(Uuid7[] data, DateTimeOffset timestamp) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        long lastMillisecond = 0;
        long millisecondCounter = 0;
        uint monotonicCounter = 0;
        for (var i = 0; i < data.Length; i++) {
            var bytes = new byte[16];
            FillBytes7(ref bytes, timestamp.UtcTicks, ref lastMillisecond, ref millisecondCounter, ref monotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
            data[i] = new Uuid7(ref bytes);
        }
    }

    /// <summary>
    /// Fills a span with version 4 UUIDs.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillUuid4(Span<Uuid7> data) {
#else
    public static void FillUuid4(Uuid7[] data) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        for (var i = 0; i < data.Length; i++) {
            var bytes = new byte[16];
            FillBytes4(ref bytes);
            data[i] = new Uuid7(ref bytes);
        }
    }

    /// <summary>
    /// Fills a span with System.Guid elements.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillGuid(Span<Guid> data) {
#else
    public static void FillGuid(Guid[] data) {
#endif
        FillGuid(data, bigEndian: IsBigEndian);
    }

    /// <summary>
    /// Fills a span with System.Guid elements.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <param name="bigEndian">If true, input will be assumed to be in a big-endian format.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillGuid(Span<Guid> data, bool bigEndian) {
#else
    public static void FillGuid(Guid[] data, bool bigEndian) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        var shouldReverse = (IsBigEndian == bigEndian);
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                if (shouldReverse) { ReverseGuidEndianess(ref bytes); }
                data[i] = new Guid(bytes);
            }
        }
    }

    /// <summary>
    /// Fills a span with version 7 UUIDs converted to System.Guid and suitable
    /// for insertion into a Microsoft SQL database. This should be used only
    /// when working with MS SQL Server and not with any other databases as byte
    /// ordering is different than usual. If you are using Uuid7 in a mixed
    /// database environment, use the FillUuid7() method instead.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillMsSqlUniqueIdentifier(Span<Guid> data) {
#else
    public static void FillMsSqlUniqueIdentifier(Guid[] data) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7MsSql(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                data[i] = new Guid(bytes);
            }
        }
    }

    /// <summary>
    /// Fills a span with version 7 UUIDs converted to System.Guid and suitable
    /// for insertion into a Microsoft SQL database. This should be used only
    /// when working with MS SQL Server and not with any other databases as byte
    /// ordering is different than usual. If you are using Uuid7 in a mixed
    /// database environment, use the FillUuid7() method instead.
    /// All UUIDs are created with the same timestamp.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <param name="timestamp">Millisecond time for when UUIDs are to be created.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillMsSqlUniqueIdentifier(Span<Guid> data, DateTimeOffset timestamp) {
#else
    public static void FillMsSqlUniqueIdentifier(Guid[] data, DateTimeOffset timestamp) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7MsSql(ref bytes, timestamp.UtcTicks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                data[i] = new Guid(bytes);
            }
        }
    }

    #endregion Static


    /// <summary>
    /// Returns current UUID as an equivalent System.Guid.
    /// </summary>
    public Guid ToGuid() {
        return ToGuid(bigEndian: IsBigEndian);
    }

    /// <summary>
    /// Converts current UUID to an equivalent System.Guid.
    /// </summary>
    /// <param name="bigEndian">If true, input will be assumed to be in a big-endian format.</param>
    public Guid ToGuid(bool bigEndian) {
        if (Bytes == null) { return Guid.Empty; }
        if (BitConverter.IsLittleEndian == bigEndian) {
            return new Guid(  // faster than calling byte[] overload
                Bytes[3] << 24 | Bytes[2] << 16 | Bytes[1] << 8 | Bytes[0],
                (short)(Bytes[5] << 8 | Bytes[4]),
                (short)(Bytes[7] << 8 | Bytes[6]),
                Bytes[8], Bytes[9], Bytes[10], Bytes[11], Bytes[12], Bytes[13], Bytes[14], Bytes[15]
            );
        } else {
            return new Guid(  // and uses less allocations too
                Bytes[0] << 24 | Bytes[1] << 16 | Bytes[2] << 8 | Bytes[3],
                (short)(Bytes[4] << 8 | Bytes[5]),
                (short)(Bytes[6] << 8 | Bytes[7]),
                Bytes[8], Bytes[9], Bytes[10], Bytes[11], Bytes[12], Bytes[13], Bytes[14], Bytes[15]
            );
        }
    }


    /// <summary>
    /// Returns an array that contains UUID bytes.
    /// Always in big-endian order.
    /// </summary>
    public byte[] ToByteArray() {
        var copy = new byte[16];
        if (Bytes != null) { Buffer.BlockCopy(Bytes, 0, copy, 0, 16); }
        return copy;
    }

    /// <summary>
    /// Returns an array that contains UUID bytes.
    /// Enginaness of bytes refers to the first 8 bytes and their handling in
    /// Guid structure.
    /// </summary>
    /// <param name="bigEndian">If true, bytes will be in big-endian (natural) order.</param>
    public byte[] ToByteArray(bool bigEndian) {
        if (Bytes == null) { return Empty.ToByteArray(); }
        if (bigEndian) {
            var copy = new byte[16];
            Buffer.BlockCopy(Bytes, 0, copy, 0, 16);
            return copy;
        } else {
            return ReverseGuidEndianess(Bytes);
        }
    }

    /// <summary>
    /// Returns DateTime based on UUID v7 timestamp.
    /// Please note that only timestamp has only 1 millisecond resolution and random bits are lost.
    /// </summary>
    /// <exception cref="InvalidOperationException">UUID is not version 7.</exception>
    public DateTime ToDateTime() {
        if (Bytes == null) { return DateTime.MinValue; }
        if ((Bytes[6] & 0xF0) != 0x70) { throw new InvalidOperationException("UUID is not version 7."); }
        var unixMs = (long)Bytes[0] << 40 | (long)Bytes[1] << 32 | (long)Bytes[2] << 24 | (long)Bytes[3] << 16 | (long)Bytes[4] << 8 | Bytes[5];
        var ticks = (UnixEpochMilliseconds + unixMs) * TicksPerMillisecond;
        return new DateTime(ticks, DateTimeKind.Utc);
    }

    /// <summary>
    /// Returns DateTimeOffset based on UUID v7 timestamp.
    /// Please note that only timestamp has only 1 millisecond resolution and random bits are lost.
    /// </summary>
    /// <exception cref="InvalidOperationException">UUID is not version 7.</exception>
    public DateTimeOffset ToDateTimeOffset() {
        if (Bytes == null) { return DateTimeOffset.MinValue; }
        if ((Bytes[6] & 0xF0) != 0x70) { throw new InvalidOperationException("UUID is not version 7."); }
        var unixMs = (long)Bytes[0] << 40 | (long)Bytes[1] << 32 | (long)Bytes[2] << 24 | (long)Bytes[3] << 16 | (long)Bytes[4] << 8 | Bytes[5];
        var ticks = (UnixEpochMilliseconds + unixMs) * TicksPerMillisecond;
        return new DateTimeOffset(ticks, TimeSpan.Zero);
    }


#if NET6_0_OR_GREATER

    /// <summary>
    /// Tries to write the current instance into a span of bytes.
    /// </summary>
    /// <param name="destination">Destination span.</param>
    public bool TryWriteBytes(Span<byte> destination) {
        if (destination.Length < 16) { return false; }  // not enough bytes
        if (Bytes != null) {
            Bytes.CopyTo(destination);
        } else {
            MinValue.Bytes.CopyTo(destination);
        }
        return true;
    }

#endif


    #region Overrides

    /// <summary>
    /// Returns true if this instance is equal to a specified object.
    /// Object can be either Uuid7 or Guid.
    /// </summary>
    /// <param name="obj">An object to compare to this instance.</param>
#if NET6_0_OR_GREATER
    public override bool Equals([NotNullWhen(true)] object? obj) {
#else
    public override bool Equals(object? obj) {
#endif
        if (obj is Uuid7 uuid) {
            return CompareArrays(Bytes, uuid.Bytes) == 0;
        } else if (obj is Guid guid) {
            var guidBytes = guid.ToByteArray();
            ReverseGuidEndianess(ref guidBytes);
            return CompareArrays(Bytes, guidBytes) == 0;
        }
        return false;
    }

    /// <summary>
    /// Returns a hash code for the current object.
    /// </summary>
    public override int GetHashCode() {
        if (Bytes == null) { return 0; }
        var hc = ((Bytes[0] ^ Bytes[6] ^ Bytes[11] ^ Bytes[15]) << 24)
               | ((Bytes[1] ^ Bytes[7] ^ Bytes[10] ^ Bytes[14]) << 16)
               | ((Bytes[2] ^ Bytes[4] ^ Bytes[9] ^ Bytes[13]) << 8)
               | (Bytes[3] ^ Bytes[5] ^ Bytes[8] ^ Bytes[12]);
        return hc;  // just XOR individual ints - compatible with Guid implementation on LE platform
    }

    /// <summary>
    /// Returns a string that represents the current object.
    /// </summary>
    public override string ToString() {
        return ToString(format: null, formatProvider: null);
    }

    #endregion Overrides


    #region Operators

    /// <summary>
    /// Returns true if both operands are equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator ==(Uuid7 left, Uuid7 right) {
        return left.Equals(right);
    }

    /// <summary>
    /// Returns true if both operands are equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator ==(Uuid7 left, Guid right) {
        return left.Equals(right);
    }

    /// <summary>
    /// Returns true if both operands are equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator ==(Guid left, Uuid7 right) {
        return left.Equals(right);
    }


    /// <summary>
    /// Returns true if both operands are not equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator !=(Uuid7 left, Uuid7 right) {
        return !(left == right);
    }

    /// <summary>
    /// Returns true if both operands are not equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator !=(Uuid7 left, Guid right) {
        return !(left == right);
    }

    /// <summary>
    /// Returns true if both operands are not equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator !=(Guid left, Uuid7 right) {
        return !(left == right);
    }


    /// <summary>
    /// Returns true if left-hand operand is less than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <(Uuid7 left, Uuid7 right) {
        return left.CompareTo(right) < 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is less than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <(Uuid7 left, Guid right) {
        return left.CompareTo(right) < 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is less than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <(Guid left, Uuid7 right) {
        return left.CompareTo(right) < 0;
    }


    /// <summary>
    /// Returns true if left-hand operand is less than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <=(Uuid7 left, Uuid7 right) {
        return left.CompareTo(right) is < 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is less than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <=(Uuid7 left, Guid right) {
        return left.CompareTo(right) is < 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is less than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <=(Guid left, Uuid7 right) {
        return left.CompareTo(right) is < 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >=(Uuid7 left, Uuid7 right) {
        return left.CompareTo(right) is > 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >=(Uuid7 left, Guid right) {
        return left.CompareTo(right) is > 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >=(Guid left, Uuid7 right) {
        return left.CompareTo(right) is > 0 or 0;
    }


    /// <summary>
    /// Returns true if left-hand operand is greater than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >(Uuid7 left, Uuid7 right) {
        return left.CompareTo(right) > 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >(Uuid7 left, Guid right) {
        return left.CompareTo(right) > 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >(Guid left, Uuid7 right) {
        return left.CompareTo(right) > 0;
    }


    /// <summary>
    /// Returns Uuid7 from given Guid.
    /// </summary>
    /// <param name="value">Value.</param>
    public static Uuid7 FromGuid(Guid value) {
        return new Uuid7(value, bigEndian: IsBigEndian);
    }

    /// <summary>
    /// Returns an Uuid7 from given Guid.
    /// </summary>
    /// <param name="value">Value.</param>
    /// <param name="bigEndian">If true, input will be assumed to be in a big-endian format.</param>
    public static Uuid7 FromGuid(Guid value, bool bigEndian) {
        var bytes = value.ToByteArray();
        if (IsBigEndian == bigEndian) { ReverseGuidEndianess(ref bytes); }
        return new Uuid7(bytes);
    }

    /// <summary>
    /// Returns an Uuid7 from given Guid.
    /// </summary>
    /// <param name="value">Value.</param>
    public static implicit operator Uuid7(Guid value) {
        return FromGuid(value);
    }

    /// <summary>
    /// Returns an Guid from given Uuid7.
    /// </summary>
    /// <param name="value">Value.</param>
    public static Guid ToGuid(Uuid7 value) {
        if (value.Bytes == null) { return Guid.Empty; }
#if NET8_0_OR_GREATER
        return new Guid(value.Bytes, true);
#else
        var bytes = new byte[16];
        Buffer.BlockCopy(value.Bytes, 0, bytes, 0, 16);
        if (BitConverter.IsLittleEndian) { ReverseGuidEndianess(ref bytes); }
        return new Guid(bytes);
#endif
    }

    /// <summary>
    /// Returns an Guid from given Uuid7.
    /// </summary>
    /// <param name="value">Value.</param>
    /// <param name="bigEndian">If true, input will be assumed to be in a big-endian format.</param>
    public static Guid ToGuid(Uuid7 value, bool bigEndian) {
        if (value.Bytes == null) { return Guid.Empty; }
#if NET8_0_OR_GREATER
        return new Guid(value.Bytes, bigEndian);
#else
        var bytes = new byte[16];
        Buffer.BlockCopy(value.Bytes, 0, bytes, 0, 16);
        if (IsBigEndian != bigEndian) { ReverseGuidEndianess(ref bytes); }
        return new Guid(bytes);
#endif
    }

/// <summary>
/// Returns UUID7 from given Guid.
/// </summary>
/// <param name="value">Value.</param>
public static implicit operator Guid(Uuid7 value) {
    return ToGuid(value);
}

    #endregion Operators

}
