/* Josip Medved <jmedved@jmedved.com> * www.medo64.com * MIT License */

namespace Medo;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Threading;

#if NET6_0_OR_GREATER
using System.ComponentModel.DataAnnotations;
using System.Diagnostics.CodeAnalysis;
#endif

#if NET7_0_OR_GREATER
using System.Runtime.Intrinsics;
#endif


/// <summary>
/// Implements UUID version 7 as defined in RFC draft at
/// https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html.
/// </summary>
[DebuggerDisplay("{ToString(),nq}")]
[StructLayout(LayoutKind.Sequential)]
public readonly struct Uuid7
    : IComparable<Guid>
    , IComparable<Uuid7>
    , IEquatable<Uuid7>
    , IEquatable<Guid>
    , IFormattable
#if NET6_0_OR_GREATER
    , ISpanFormattable
#endif
#if NET7_0_OR_GREATER
    , ISpanParsable<Uuid7>
#endif
{

    /// <summary>
    /// Creates a new version 7 UUID.
    /// Sequencing is done on a per-thread basis. This means that each thread
    /// maintains a separate counter, and thus sequences generated by different
    /// threads might overlap. Please note that this overlap is no  worse than
    /// what one would expect if the code was executing on a different computer.
    /// However, if strict sequencing is required, please use the static
    /// NewUuid7() method that guarantees this behavior.
    /// </summary>
    public Uuid7() {
        _bytes = new byte[16];
        FillBytes7(ref _bytes, DateTime.UtcNow.Ticks, ref PerThreadLastMillisecond, ref PerThreadMillisecondCounter, ref PerThreadMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
    }

    /// <summary>
    /// Creates a new instance from given byte array.
    /// No check if array is version 7 UUID is made.
    /// </summary>
    /// <exception cref="ArgumentNullException">Buffer cannot be null.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Buffer must be exactly 16 bytes in length.</exception>
    public Uuid7(byte[] buffer) {
        if (buffer == null) { throw new ArgumentNullException(nameof(buffer), "Buffer cannot be null."); }
        if (buffer.Length != 16) { throw new ArgumentOutOfRangeException(nameof(buffer), "Buffer must be exactly 16 bytes in length."); }
        _bytes = new byte[16];
        Buffer.BlockCopy(buffer, 0, Bytes, 0, 16);
    }

#if NET6_0_OR_GREATER
    /// <summary>
    /// Creates a new instance from given read-only byte span.
    /// No check if array is version 7 UUID is made.
    /// </summary>
    /// <exception cref="ArgumentNullException">Span cannot be null.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Span must be exactly 16 bytes in length.</exception>
    public Uuid7(ReadOnlySpan<byte> span) {
        if (span.Length != 16) { throw new ArgumentOutOfRangeException(nameof(span), "Span must be exactly 16 bytes in length."); }
        _bytes = new byte[16];
        span.CopyTo(Bytes);
    }
#endif

    /// <summary>
    /// Creates a new instance from given GUID bytes.
    /// No check if GUID is version 7 UUID is made.
    /// </summary>
    /// <param name="guid">Guid.</param>
    public Uuid7(Guid guid) {
        _bytes = guid.ToByteArray();
    }

    /// <summary>
    /// Creates a new instance from given GUID bytes.
    /// No check if GUID is version 7 UUID is made.
    /// </summary>
    /// <param name="guid">Guid.</param>
    /// <param name="matchGuidEndianness">If true, conversion will also adjust endianess so that textual representation matches System.Guid.</param>
    public Uuid7(Guid guid, bool matchGuidEndianness) {
        if (matchGuidEndianness) {
            var bytes = guid.ToByteArray();
            AdjustGuidEndianess(ref bytes);
            _bytes = bytes;
        } else {
            _bytes = guid.ToByteArray();
        }
    }


    /// <summary>
    /// Creates a new instance with a given byte array.
    /// No check if array is version 7 UUID is made.
    /// No check for array length is made.
    /// </summary>
    private Uuid7(ref byte[] buffer) {
        _bytes = buffer;
    }

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
    private readonly byte[] _bytes;

    private byte[] Bytes => _bytes ?? Empty._bytes;


    #region Static

    /// <summary>
    /// A read-only instance of the Uuid7 structure whose value is all zeros.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 MinValue = new(new byte[16]);

    /// <summary>
    /// A read-only instance of the Uuid7 structure whose value is all ones.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 MaxValue = new(new byte[] { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 });

    /// <summary>
    /// A read-only instance of the Uuid7 structure whose value is all zeros.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 Empty = MinValue;


    /// <summary>
    /// Returns a new UUID version 7.
    /// This method is thread-safe.
    /// For higher multi-threaded performance, consider using new Uuid7()
    /// instead, as it utilizes per-thread counters. While this doesn't
    /// guarantee strict sequencing, it provides no worse results than
    /// generating UUIDs on multiple computers.
    /// </summary>
    public static Uuid7 NewUuid7() {
        var bytes = new byte[16];
        lock (NonThreadedSyncRoot) {
            FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
        }
        return new Uuid7(ref bytes);
    }

    /// <summary>
    /// Returns a new UUID version 7 with a specific timestamp.
    /// This is not recommended for general use since it doesn't offer the same collision protections as the default NewUuid7() method.
    /// This method is thread-safe.
    /// </summary>
    public static Uuid7 NewUuid7(DateTimeOffset timestamp) {
        var bytes = new byte[16];
        long lastMillisecond = 0;
        long millisecondCounter = 0;
        uint monotonicCounter = 0;
        FillBytes7(ref bytes, timestamp.UtcTicks, ref lastMillisecond, ref millisecondCounter, ref monotonicCounter);
        return new Uuid7(ref bytes);
    }

    /// <summary>
    /// Returns new UUID version 4.
    /// This method is thread-safe.
    /// </summary>
    public static Uuid7 NewUuid4() {
        var bytes = new byte[16];
        FillBytes4(ref bytes);
        return new Uuid7(ref bytes);
    }

    /// <summary>
    /// Returns a binary equivalent System.Guid of a UUID version 7.
    /// This method is thread-safe.
    /// </summary>
    public static Guid NewGuid() {
        var bytes = new byte[16];
        lock (NonThreadedSyncRoot) {
            FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
        }
        return new Guid(bytes);
    }

    /// <summary>
    /// Returns a binary equivalent System.Guid of a UUID version 7.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="matchGuidEndianness">If true, conversion will also adjust endianess so that textual representation matches System.Guid.</param>
    public static Guid NewGuid(bool matchGuidEndianness) {
        var bytes = new byte[16];
        lock (NonThreadedSyncRoot) {
            FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
        }
        if (matchGuidEndianness) { AdjustGuidEndianess(ref bytes); }
        return new Guid(bytes);
    }


    /// <summary>
    /// Returns Guid with endianess matching one of the system.
    /// NOT suitable for insertion into Microsoft SQL database.
    /// </summary>
    [Obsolete("For UniqueIdentifier Use NewMsSqlUniqueIdentifier() or NewGuid(matchGuidEndianness: true) instead, depending on desired behavior.", error: true)]
    public static Guid NewGuidMsSql() {
        return NewGuid(matchGuidEndianness: true);
    }

    /// <summary>
    /// Returns a System.Guid of a UUID version 7 suitable for insertion into a
    /// Microsoft SQL database. This should be used only when working with MS
    /// SQL Server and not with any other databases as byte ordering is
    /// different than usual. If you are using Uuid7 in a mixed database
    /// environment, use the NewUuid7() method instead.
    /// This method is thread-safe.
    /// </summary>
    public static Guid NewMsSqlUniqueIdentifier() {
        var bytes = new byte[16];
        lock (NonThreadedSyncRoot) {
            FillBytes7MsSql(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
        }
        return new Guid(bytes);
    }


    /// <summary>
    /// Fills a span with version 7 UUIDs.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void Fill(Span<Uuid7> data) {
#else
    public static void Fill(Uuid7[] data) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                data[i] = new Uuid7(ref bytes);
            }
        }
    }

    /// <summary>
    /// Fills a span with version 7 UUIDs.
    /// All UUIDs are created with the same timestamp.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <param name="timestamp">Millisecond time for when UUIDs are to be created.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void Fill(Span<Uuid7> data, DateTimeOffset timestamp) {
#else
    public static void Fill(Uuid7[] data, DateTimeOffset timestamp) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        long lastMillisecond = 0;
        long millisecondCounter = 0;
        uint monotonicCounter = 0;
        for (var i = 0; i < data.Length; i++) {
            var bytes = new byte[16];
            FillBytes7(ref bytes, timestamp.UtcTicks, ref lastMillisecond, ref millisecondCounter, ref monotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
            data[i] = new Uuid7(ref bytes);
        }
    }

    /// <summary>
    /// Fills a span with version 4 UUIDs.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillUuid4(Span<Uuid7> data) {
#else
    public static void FillUuid4(Uuid7[] data) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        for (var i = 0; i < data.Length; i++) {
            var bytes = new byte[16];
            FillBytes4(ref bytes);
            data[i] = new Uuid7(ref bytes);
        }
    }

    /// <summary>
    /// Fills a span with binary-compatible System.Guid elements.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillGuid(Span<Guid> data) {
#else
    public static void FillGuid(Guid[] data) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                data[i] = new Guid(bytes);
            }
        }
    }

    /// <summary>
    /// Fills a span with binary-compatible System.Guid elements.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <param name="matchGuidEndianness">If true, conversion will also adjust endianess so that textual representation matches System.Guid.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillGuid(Span<Guid> data, bool matchGuidEndianness) {
#else
    public static void FillGuid(Guid[] data, bool matchGuidEndianness) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                if (matchGuidEndianness) { AdjustGuidEndianess(ref bytes); }
                data[i] = new Guid(bytes);
            }
        }
    }

    /// <summary>
    /// Fills a span with version 7 UUIDs converted to System.Guid and suitable
    /// for insertion into a Microsoft SQL database. This should be used only
    /// when working with MS SQL Server and not with any other databases as byte
    /// ordering is different than usual. If you are using Uuid7 in a mixed
    /// database environment, use the FillUuid7() method instead.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillMsSqlUniqueIdentifier(Span<Guid> data) {
#else
    public static void FillMsSqlUniqueIdentifier(Guid[] data) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7MsSql(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                data[i] = new Guid(bytes);
            }
        }
    }

    /// <summary>
    /// Fills a span with version 7 UUIDs converted to System.Guid and suitable
    /// for insertion into a Microsoft SQL database. This should be used only
    /// when working with MS SQL Server and not with any other databases as byte
    /// ordering is different than usual. If you are using Uuid7 in a mixed
    /// database environment, use the FillUuid7() method instead.
    /// All UUIDs are created with the same timestamp.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <param name="timestamp">Millisecond time for when UUIDs are to be created.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillMsSqlUniqueIdentifier(Span<Guid> data, DateTimeOffset timestamp) {
#else
    public static void FillMsSqlUniqueIdentifier(Guid[] data, DateTimeOffset timestamp) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7MsSql(ref bytes, timestamp.UtcTicks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                data[i] = new Guid(bytes);
            }
        }
    }

    #endregion Static


    #region Implementation (v7)

#if NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static void FillBytes7(ref byte[] bytes, long ticks, ref long lastMillisecond, ref long millisecondCounter, ref uint monotonicCounter) {
        //   0                   1                   2                   3
        //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        //  |                       unix_ts_ms[47:16]                       |
        //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        //  |       unix_ts_ms[15:0]        |  ver  |    counter[25:14]     |
        //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        //  |var|       counter[13:0]       |            random             |
        //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        //  |                            random                             |
        //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        var millisecond = unchecked(ticks / TicksPerMillisecond);
        var msCounter = millisecondCounter;

        var newStep = (millisecond != lastMillisecond);
        if (newStep) {  // we need to switch millisecond (i.e. counter)
            lastMillisecond = millisecond;
            long ms;
            ms = unchecked(millisecond - UnixEpochMilliseconds);
            if (msCounter < ms) {  // normal time progression
                msCounter = ms;
            } else {  // time went backward, just increase counter
                unchecked { msCounter++; }
            }
            millisecondCounter = msCounter;
        }

        // Timestamp
        bytes[0] = (byte)(msCounter >> 40);
        bytes[1] = (byte)(msCounter >> 32);
        bytes[2] = (byte)(msCounter >> 24);
        bytes[3] = (byte)(msCounter >> 16);
        bytes[4] = (byte)(msCounter >> 8);
        bytes[5] = (byte)msCounter;

        // Randomness
        uint monoCounter;
        if (newStep) {
            GetRandomBytes(ref bytes, 6, 10);
            monoCounter = (uint)(((bytes[6] & 0x07) << 22) | (bytes[7] << 14) | ((bytes[8] & 0x3F) << 8) | bytes[9]);  // to use as monotonic random for future calls; total of 26 bits but only 25 are used initially with upper 1 bit reserved for rollover guard
        } else {
            GetRandomBytes(ref bytes, 9, 7);
            monoCounter = unchecked(monotonicCounter + ((uint)bytes[9] >> 4) + 1);  // 4 bit random increment will reduce overall counter space by 3 bits on average (to 2^22 combinations)
            bytes[7] = (byte)(monoCounter >> 14);    // bits 14:21 of monotonics counter
            bytes[9] = (byte)(monoCounter);          // bits 0:7 of monotonics counter
        }
        monotonicCounter = monoCounter;

        //Fixup
        bytes[6] = (byte)(0x70 | ((monoCounter >> 22) & 0x0F));  // set 4-bit version + bits 22:25 of monotonics counter
        bytes[8] = (byte)(0x80 | ((monoCounter >> 8) & 0x3F));   // set 2-bit variant + bits 8:13 of monotonics counter
    }

#if NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static void FillBytes7MsSql(ref byte[] bytes, long ticks, ref long lastMillisecond, ref long millisecondCounter, ref uint monotonicCounter) {
        //   0                   1                   2                   3
        //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        //  |                            random                             |
        //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        //  |            random             |  ver  |     counter[11:0]     |
        //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        //  |var|      counter[25:12]       |       unix_ts_ms[47:32]       |
        //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        //  |                       unix_ts_ms[31:0]                        |
        //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        var millisecond = unchecked(ticks / TicksPerMillisecond);
        var msCounter = millisecondCounter;

        var newStep = (millisecond != lastMillisecond);
        if (newStep) {  // we need to switch millisecond (i.e. counter)
            lastMillisecond = millisecond;
            long ms;
            ms = unchecked(millisecond - UnixEpochMilliseconds);
            if (msCounter < ms) {  // normal time progression
                msCounter = ms;
            } else {  // time went backward, just increase counter
                unchecked { msCounter++; }
            }
            millisecondCounter = msCounter;
        }

        // Timestamp
        bytes[10] = (byte)(msCounter >> 40);
        bytes[11] = (byte)(msCounter >> 32);
        bytes[12] = (byte)(msCounter >> 24);
        bytes[13] = (byte)(msCounter >> 16);
        bytes[14] = (byte)(msCounter >> 8);
        bytes[15] = (byte)msCounter;

        // Randomness
        uint monoCounter;
        if (newStep) {
            GetRandomBytes(ref bytes, 0, 10);
            monoCounter = (uint)(((bytes[8] & 0x1F) << 20) | (bytes[9] << 12) | ((bytes[6] & 0x0F) << 8) | bytes[7]);  // to use as monotonic random for future calls; total of 26 bits but only 25 are used initially with upper 1 bit reserved for rollover guard
        } else {
            GetRandomBytes(ref bytes, 0, 7);
            monoCounter = unchecked(monotonicCounter + ((uint)bytes[7] >> 4) + 1);  // 4 bit random increment will reduce overall counter space by 3 bits on average (to 2^22 combinations)
            bytes[9] = (byte)(monoCounter >> 12);  // bits 12:19 of monotonics counter
            bytes[7] = (byte)(monoCounter);        // bits 0:7 of monotonics counter
        }
        monotonicCounter = monoCounter;

        //Fixup
        bytes[6] = (byte)(0x70 | ((monoCounter >> 8) & 0x0F));   // set 4-bit version + bits 8:11 of monotonics counter
        bytes[8] = (byte)(0x80 | ((monoCounter >> 20) & 0x3F));  // set 2-bit variant + bits 20:25 of monotonics counter
    }


    [ThreadStatic]
    private static long PerThreadLastMillisecond;  // real time in milliseconds since 0001-01-01

    [ThreadStatic]
    private static long PerThreadMillisecondCounter;  // usually real time but doesn't go backward

    [ThreadStatic]
    private static uint PerThreadMonotonicCounter;  // counter that gets embedded into UUID

    private static readonly object NonThreadedSyncRoot = new();  // sync root for all static counters
    private static long NonThreadedLastMillisecond;  // real time in milliseconds since 0001-01-01
    private static long NonThreadedMillisecondCounter;  // usually real time but doesn't go backward
    private static uint NonThreadedMonotonicCounter;  // counter that gets embedded into UUID

    #endregion Implementation (v7)


    #region Implementation (v4)

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void FillBytes4(ref byte[] bytes) {
        GetRandomBytes(ref bytes, 0, 16);

        //Fixup
        bytes[6] = (byte)(0x40 | (bytes[6] & 0x0F));  // set 4-bit version
        bytes[8] = (byte)(0x20 | (bytes[8] & 0x3F));  // set 2-bit variant
    }

    #endregion Implementation (v4)


    #region Endianess

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void AdjustGuidEndianess(ref byte[] bytes) {
        if (BitConverter.IsLittleEndian) {  // swap a few bytes on little-endian
            (bytes[0], bytes[1], bytes[2], bytes[3]) = (bytes[3], bytes[2], bytes[1], bytes[0]);
            (bytes[4], bytes[5]) = (bytes[5], bytes[4]);
            (bytes[6], bytes[7]) = (bytes[7], bytes[6]);
        }
    }

    #endregion Endianess


    /// <summary>
    /// Returns current UUID as binary equivalent System.Guid.
    /// </summary>
    public Guid ToGuid() {
        return new Guid(Bytes);
    }

    /// <summary>
    /// Returns current UUID as either binary or text equivalent System.Guid.
    /// </summary>
    /// <param name="matchGuidEndianness">If true, result will also have endianess adjusted so that textual representation matches System.Guid.</param>
    public Guid ToGuid(bool matchGuidEndianness) {
        if (matchGuidEndianness) {
            var bytes = ToByteArray();
            AdjustGuidEndianess(ref bytes);
            return new Guid(bytes);
        } else {
            return new Guid(Bytes);
        }
    }

    /// <summary>
    /// Returns Guid with endianess matching one of the system.
    /// NOT suitable for insertion into Microsoft SQL database.
    /// </summary>
    [Obsolete("Use NewMsSqlUniqueIdentifier() or ToGuid(matchGuidEndianness: true) instead, depending on desired behavior.", error: true)]
    public Guid ToGuidMsSql() {
        return ToGuid(matchGuidEndianness: true);
    }


    /// <summary>
    /// Returns an array that contains UUID bytes.
    /// </summary>
    public byte[] ToByteArray() {
        var copy = new byte[16];
        if (Bytes != null) { Buffer.BlockCopy(Bytes, 0, copy, 0, 16); }
        return copy;
    }

    /// <summary>
    /// Returns an array that contains UUID bytes.
    /// Enginaness of bytes refers to the first 8 bytes and their handling in
    /// Guid structure.
    /// </summary>
    /// <param name="bigEndian">If true, bytes will be in big-endian (natural) order.</param>
    public byte[] ToByteArray(bool bigEndian) {
        var copy = new byte[16];
        Buffer.BlockCopy(Bytes, 0, copy, 0, 16);
        if (bigEndian) {
            return copy;
        } else {
            AdjustGuidEndianess(ref copy);
        }
        return copy;
    }

    /// <summary>
    /// Returns DateTime based on UUID v7 timestamp.
    /// Please note that only timestamp has only 1 millisecond resolution and random bits are lost.
    /// </summary>
    /// <exception cref="InvalidOperationException">UUID is not version 7.</exception>
    public DateTime ToDateTime() {
        if ((Bytes[6] & 0xF0) != 0x70) { throw new InvalidOperationException("UUID is not version 7."); }
        var unixMs = (long)Bytes[0] << 40 | (long)Bytes[1] << 32 | (long)Bytes[2] << 24 | (long)Bytes[3] << 16 | (long)Bytes[4] << 8 | (long)Bytes[5];
        var ticks = (UnixEpochMilliseconds + unixMs) * TicksPerMillisecond;
        return new DateTime(ticks, DateTimeKind.Utc);
    }

    /// <summary>
    /// Returns DateTimeOffset based on UUID v7 timestamp.
    /// Please note that only timestamp has only 1 millisecond resolution and random bits are lost.
    /// </summary>
    /// <exception cref="InvalidOperationException">UUID is not version 7.</exception>
    public DateTimeOffset ToDateTimeOffset() {
        if ((Bytes[6] & 0xF0) != 0x70) { throw new InvalidOperationException("UUID is not version 7."); }
        var unixMs = (long)Bytes[0] << 40 | (long)Bytes[1] << 32 | (long)Bytes[2] << 24 | (long)Bytes[3] << 16 | (long)Bytes[4] << 8 | (long)Bytes[5];
        var ticks = (UnixEpochMilliseconds + unixMs) * TicksPerMillisecond;
        return new DateTimeOffset(ticks, TimeSpan.Zero);
    }


#if NET6_0_OR_GREATER

    /// <summary>
    /// Tries to write the current instance into a span of bytes.
    /// </summary>
    /// <param name="destination">Destination span.</param>
    public bool TryWriteBytes(Span<byte> destination) {
        if (destination.Length < 16) { return false; }  // not enough bytes
        if (Bytes != null) {
            Bytes.CopyTo(destination);
        } else {
            MinValue.Bytes.CopyTo(destination);
        }
        return true;
    }

#endif


    #region String

    /// <summary>
    /// Returns UUID from given text representation.
    /// All characters not belonging to hexadecimal alphabet are ignored.
    /// Input must contain exactly 32 hexadecimal characters.
    /// The following formats are supported: D, N, B, and P.
    /// </summary>
    /// <param name="text">UUID text.</param>
    /// <exception cref="ArgumentNullException">Text cannot be null.</exception>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
    public static Uuid7 FromString(string text) {
        return Parse(text, provider: null);
    }


    /// <summary>
    /// Returns UUID representation in Id25 format.
    /// Please note that while conversion is the same as one in
    /// https://github.com/stevesimmons/uuid7-csharp/, UUIDs are not fully
    /// compatible and thus not necessarily interchangeable.
    /// </summary>
    public string ToId25String() {
        return ToString(format: "5", formatProvider: null);
    }

    /// <summary>
    /// Returns UUID from given text representation.
    /// All characters not belonging to Id25 alphabet are ignored.
    /// Input must contain exactly 25 characters.
    /// </summary>
    /// <param name="id25Text">Id25 text.</param>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
#if NET6_0_OR_GREATER
    public static Uuid7 FromId25String(ReadOnlySpan<char> id25Text) {
        if (TryParseAsId25(id25Text, out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }
#else
    public static Uuid7 FromId25String(string id25Text) {
        if (id25Text == null) { throw new ArgumentNullException(nameof(id25Text), "Text cannot be null."); }
        if (TryParseAsId25(id25Text.ToCharArray(), out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }
#endif


    /// <summary>
    /// Returns UUID representation in Id22 format. This is base58 encoder
    /// using the same alphabet as bitcoin does.
    /// </summary>
    public string ToId22String() {
        return ToString(format: "2", formatProvider: null);
    }

    /// <summary>
    /// Returns UUID from given text representation.
    /// All characters not belonging to Id22 alphabet are ignored.
    /// Input must contain exactly 22 characters.
    /// </summary>
    /// <param name="id22Text">Id22 text.</param>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
#if NET6_0_OR_GREATER
    public static Uuid7 FromId22String(ReadOnlySpan<char> id22Text) {
        if (TryParseAsId22(id22Text, out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }
#else
    public static Uuid7 FromId22String(string id22Text) {
        if (id22Text == null) { throw new ArgumentNullException(nameof(id22Text), "Text cannot be null."); }
        if (TryParseAsId22(id22Text.ToCharArray(), out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }
#endif

    #endregion String


    #region Overrides

    /// <summary>
    /// Returns true if this instance is equal to a specified object.
    /// Object can be either Uuid7 or Guid.
    /// </summary>
    /// <param name="obj">An object to compare to this instance.</param>
#if NET6_0_OR_GREATER
    public override bool Equals([NotNullWhen(true)] object? obj) {
#else
    public override bool Equals(object? obj) {
#endif
        if (obj is Uuid7 uuid) {
            return CompareArrays(Bytes, uuid.Bytes) == 0;
        } else if (obj is Guid guid) {
            return CompareArrays(Bytes, guid.ToByteArray()) == 0;
        }
        return false;
    }

    /// <summary>
    /// Returns a hash code for the current object.
    /// </summary>
    public override int GetHashCode() {
        var hc = ((Bytes[3] ^ Bytes[7] ^ Bytes[11] ^ Bytes[15]) << 24)
               | ((Bytes[2] ^ Bytes[6] ^ Bytes[10] ^ Bytes[14]) << 16)
               | ((Bytes[1] ^ Bytes[5] ^ Bytes[9] ^ Bytes[13]) << 8)
               | (Bytes[0] ^ Bytes[4] ^ Bytes[8] ^ Bytes[12]);
        return hc;  // just XOR individual ints - compatible with Guid implementation on LE platform
    }

    /// <summary>
    /// Returns a string that represents the current object.
    /// </summary>
    public override string ToString() {
        return ToString(format: null, formatProvider: null);
    }

    #endregion Overrides


    #region Operators

    /// <summary>
    /// Returns true if both operands are equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator ==(Uuid7 left, Uuid7 right) {
        return left.Equals(right);
    }

    /// <summary>
    /// Returns true if both operands are equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator ==(Uuid7 left, Guid right) {
        return left.Equals(right);
    }

    /// <summary>
    /// Returns true if both operands are equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator ==(Guid left, Uuid7 right) {
        return left.Equals(right);
    }


    /// <summary>
    /// Returns true if both operands are not equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator !=(Uuid7 left, Uuid7 right) {
        return !(left == right);
    }

    /// <summary>
    /// Returns true if both operands are not equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator !=(Uuid7 left, Guid right) {
        return !(left == right);
    }

    /// <summary>
    /// Returns true if both operands are not equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator !=(Guid left, Uuid7 right) {
        return !(left == right);
    }


    /// <summary>
    /// Returns true if left-hand operand is less than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <(Uuid7 left, Uuid7 right) {
        return left.CompareTo(right) < 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is less than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <(Uuid7 left, Guid right) {
        return left.CompareTo(right) < 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is less than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <(Guid left, Uuid7 right) {
        return left.CompareTo(right) < 0;
    }


    /// <summary>
    /// Returns true if left-hand operand is less than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <=(Uuid7 left, Uuid7 right) {
        return left.CompareTo(right) is < 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is less than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <=(Uuid7 left, Guid right) {
        return left.CompareTo(right) is < 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is less than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <=(Guid left, Uuid7 right) {
        return left.CompareTo(right) is < 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >=(Uuid7 left, Uuid7 right) {
        return left.CompareTo(right) is > 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >=(Uuid7 left, Guid right) {
        return left.CompareTo(right) is > 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >=(Guid left, Uuid7 right) {
        return left.CompareTo(right) is > 0 or 0;
    }


    /// <summary>
    /// Returns true if left-hand operand is greater than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >(Uuid7 left, Uuid7 right) {
        return left.CompareTo(right) > 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >(Uuid7 left, Guid right) {
        return left.CompareTo(right) > 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >(Guid left, Uuid7 right) {
        return left.CompareTo(right) > 0;
    }


    /// <summary>
    /// Returns binary-compatible Uuid7 from given Guid.
    /// </summary>
    /// <param name="value">Value.</param>
    public static Uuid7 FromGuid(Guid value) {
        return new Uuid7(value.ToByteArray());
    }

    /// <summary>
    /// Returns binary or text compatible Uuid7 from given Guid.
    /// </summary>
    /// <param name="value">Value.</param>
    /// <param name="matchGuidEndianness">If true, conversion will also adjust endianess so that textual representation matches System.Guid.</param>
    public static Uuid7 FromGuid(Guid value, bool matchGuidEndianness) {
        var bytes = value.ToByteArray();
        if (matchGuidEndianness) { AdjustGuidEndianess(ref bytes); }
        return new Uuid7(bytes);
    }

    /// <summary>
    /// Returns binary-compatible Uuid7 from given Guid.
    /// </summary>
    /// <param name="value">Value.</param>
    public static implicit operator Uuid7(Guid value) {
        return FromGuid(value);
    }

    /// <summary>
    /// Returns binary-compatible Guid from given Uuid7.
    /// </summary>
    /// <param name="value">Value.</param>
    public static Guid ToGuid(Uuid7 value) {
        return new Guid(value.Bytes);
    }

    /// <summary>
    /// Returns binary or text compatible Guid from given Uuid7.
    /// </summary>
    /// <param name="value">Value.</param>
    /// <param name="matchGuidEndianness">If true, conversion will also adjust endianess so that textual representation matches System.Guid.</param>
    public static Guid ToGuid(Uuid7 value, bool matchGuidEndianness) {
        var bytes = new byte[16];
        Buffer.BlockCopy(value.Bytes, 0, bytes, 0, 16);
        if (matchGuidEndianness) { AdjustGuidEndianess(ref bytes); }
        return new Guid(bytes);
    }

    /// <summary>
    /// Returns UUID7 from given Guid.
    /// </summary>
    /// <param name="value">Value.</param>
    public static implicit operator Guid(Uuid7 value) {
        return ToGuid(value);
    }

    #endregion Operators


    #region IComparable<Guid>

    /// <summary>
    /// Compares this instance to a specified Guid object and returns an indication of their relative values.
    /// A negative integer if this instance is less than value; a positive integer if this instance is greater than value; or zero if this instance is equal to value.
    /// GUID and UUID are compared for their binary value.
    /// </summary>
    /// <param name="other">An object to compare to this instance.</param>
    public int CompareTo(Guid other) {
        return CompareArrays(Bytes, other.ToByteArray());
    }

    #endregion IComparable<Guid>


    #region IComparable<Uuid>

    /// <summary>
    /// Compares this instance to a specified Guid object and returns an indication of their relative values.
    /// A negative integer if this instance is less than value; a positive integer if this instance is greater than value; or zero if this instance is equal to value.
    /// </summary>
    /// <param name="other">An object to compare to this instance.</param>
    public int CompareTo(Uuid7 other) {
        return CompareArrays(Bytes, other.Bytes);
    }

    #endregion IComparable<Uuid>


    #region IEquatable<Guid>

    /// <summary>
    /// Returns a value that indicates whether this instance is equal to a specified object.
    /// Objects are considered equal if they have the same binary representation.
    /// </summary>
    /// <param name="other">An object to compare to this instance.</param>
    public bool Equals(Guid other) {
#if NET7_0_OR_GREATER
        if (Vector128.IsHardwareAccelerated) {
            var vector1 = Unsafe.ReadUnaligned<Vector128<byte>>(ref Bytes[0]);
            var vector2 = Unsafe.ReadUnaligned<Vector128<byte>>(ref other.ToByteArray()[0]);
            return vector1 == vector2;
        }
#endif
        return CompareArrays(Bytes, other.ToByteArray()) == 0;
    }

    #endregion IEquatable<Guid>


    #region IEquatable<Uuid>

    /// <summary>
    /// Returns a value that indicates whether this instance is equal to a specified object.
    /// </summary>
    /// <param name="other">An object to compare to this instance.</param>
    public bool Equals(Uuid7 other) {
#if NET7_0_OR_GREATER
        if (Vector128.IsHardwareAccelerated) {
            var vector1 = Unsafe.ReadUnaligned<Vector128<byte>>(ref Bytes[0]);
            if (other.Bytes == null) {
                return vector1 == Vector128<byte>.Zero;
            } else {
                var vector2 = Unsafe.ReadUnaligned<Vector128<byte>>(ref other.Bytes[0]);
                return vector1 == vector2;
            }
        }
#endif
        return CompareArrays(Bytes, other.Bytes) == 0;
    }

    #endregion IEquatable<Uuid>


    #region IFormattable

    /// <summary>
    /// Formats the value of the current instance using the specified format.
    /// The following format specifiers are supported:
    /// - D: Default - 32 digits separated by hyphens, e.g. 00000000-0000-0000-0000-000000000000
    /// - N: No hyphen - 32 digits, e.g. 00000000000000000000000000000000
    /// - B: Braces - 	32 digits separated by hyphens, enclosed in braces, e.g. {00000000-0000-0000-0000-000000000000}
    /// - P: Parentheses - 32 digits separated by hyphens, enclosed in parentheses, e.g. (00000000-0000-0000-0000-000000000000)
    /// - X: Hexadecimal - Four hexadecimal values enclosed in braces, where the fourth value is a subset of eight hexadecimal values that is also enclosed in braces, e.g. {0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} - for the love of all that is holy do not use this format
    /// - 5: Id25 - 25 characters from a case-insensitive 35 character alphabet, e.g. 0000000000000000000000000
    /// - 2: Id22 - 22 characters from a 58 character alphabet, e.g. 0000000000000000000000
    /// </summary>
    /// <param name="format">The format to use.</param>
#if NET7_0_OR_GREATER
    public string ToString([StringSyntax(StringSyntaxAttribute.GuidFormat)] string? format) {
#else
    public string ToString(string? format) {
#endif
        return ToString(format, formatProvider: null);
    }

    /// <summary>
    /// Formats the value of the current instance using the specified format.
    /// The following format specifiers are supported:
    /// - D: Default - 32 digits separated by hyphens, e.g. 00000000-0000-0000-0000-000000000000
    /// - N: No hyphen - 32 digits, e.g. 00000000000000000000000000000000
    /// - B: Braces - 	32 digits separated by hyphens, enclosed in braces, e.g. {00000000-0000-0000-0000-000000000000}
    /// - P: Parentheses - 32 digits separated by hyphens, enclosed in parentheses, e.g. (00000000-0000-0000-0000-000000000000)
    /// - X: Hexadecimal - Four hexadecimal values enclosed in braces, where the fourth value is a subset of eight hexadecimal values that is also enclosed in braces, e.g. {0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} - for the love of all that is holy do not use this format
    /// - 5: Id25 - 25 characters from a case-insensitive 35 character alphabet, e.g. 0000000000000000000000000
    /// - 2: Id22 - 22 characters from a 58 character alphabet, e.g. 0000000000000000000000
    /// </summary>
    /// <param name="format">The format to use.</param>
    /// <param name="formatProvider">Not used.</param>
#if NET7_0_OR_GREATER
    public string ToString([StringSyntax(StringSyntaxAttribute.GuidFormat)] string? format, IFormatProvider? formatProvider) {
#else
    public string ToString(string? format, IFormatProvider? formatProvider) {  // formatProvider is ignored
#endif
        switch (format) {  // treat uppercase and lowercase the same (compatibility with Guid ToFormat)
            case null:
            case "":
            case "D":
            case "d": {
#if NET6_0_OR_GREATER
                    return string.Create(36, Bytes, static (destination, bytes)
                        => TryWriteAsDefaultString(destination, bytes, out _));
#else
                    var destination = new char[36];
                    TryWriteAsDefaultString(destination, Bytes, out _);
                    return new string(destination);
#endif
                }
            case "N":
            case "n": {
#if NET6_0_OR_GREATER
                    return string.Create(32, Bytes, static (destination, bytes)
                        => TryWriteAsNoHypensString(destination, bytes, out _));
#else
                    var destination = new char[32];
                    TryWriteAsNoHypensString(destination, Bytes, out _);
                    return new string(destination);
#endif
                }
            case "B":
            case "b": {
#if NET6_0_OR_GREATER
                    return string.Create(38, Bytes, static (destination, bytes)
                        => TryWriteAsBracesString(destination, bytes, out _));
#else
                    var destination = new char[38];
                    TryWriteAsBracesString(destination, Bytes, out _);
                    return new string(destination);
#endif
                }
            case "P":
            case "p": {
#if NET6_0_OR_GREATER
                    return string.Create(38, Bytes, static (destination, bytes)
                        => TryWriteAsParenthesesString(destination, bytes, out _));
#else
                    var destination = new char[38];
                    TryWriteAsParenthesesString(destination, Bytes, out _);
                    return new string(destination);
#endif
                }
            case "X":
            case "x": {
#if NET6_0_OR_GREATER
                    return string.Create(68, Bytes, static (destination, bytes)
                        => TryWriteAsHexadecimalString(destination, bytes, out _));
#else
                    var destination = new char[68];
                    TryWriteAsHexadecimalString(destination, Bytes, out _);
                    return new string(destination);
#endif
                }
            case "5": {  // non-standard (Id25)
#if NET6_0_OR_GREATER
                    return string.Create(25, Bytes, static (destination, bytes)
                        => TryWriteAsId25(destination, bytes, out _));
#else
                    var destination = new char[25];
                    TryWriteAsId25(destination, Bytes, out _);
                    return new string(destination);
#endif
                }
            case "2": {  // non-standard (Id22)
#if NET6_0_OR_GREATER
                    return string.Create(22, Bytes, static (destination, bytes)
                        => TryWriteAsId22(destination, bytes, out _));
#else
                    var destination = new char[22];
                    TryWriteAsId22(destination, Bytes, out _);
                    return new string(destination);
#endif
                }
            default: throw new FormatException("Invalid UUID format.");
        }
    }

    #endregion IFormattable


    #region ISpanFormattable

#if NET7_0_OR_GREATER
    /// <summary>
    /// Tries to format the current instance into the provided character span.
    /// </summary>
    /// <param name="destination">The span in which to write.</param>
    /// <param name="charsWritten">When this method returns, contains the number of characters written into the span.</param>
    /// <param name="format">A read-only span containing the character representing one of the following specifiers that indicates the exact format to use when interpreting input: "N", "D", "B", "P", or "X".</param>
    /// <param name="provider">Not used.</param>
    /// <exception cref="NotImplementedException"></exception>
    public bool TryFormat(Span<char> destination, out int charsWritten, [StringSyntax(StringSyntaxAttribute.GuidFormat)] ReadOnlySpan<char> format, IFormatProvider? provider) {  // formatProvider is ignored
        if (format.Length > 1) { charsWritten = 0; return false; }

        var formatChar = (format.Length == 1) ? format[0] : 'D';
        return formatChar switch {  // treat uppercase and lowercase the same (compatibility with Guid ToFormat)
            'D' or 'd' => TryWriteAsDefaultString(destination, Bytes, out charsWritten),
            'N' or 'n' => TryWriteAsNoHypensString(destination, Bytes, out charsWritten),
            'B' or 'b' => TryWriteAsBracesString(destination, Bytes, out charsWritten),
            'P' or 'p' => TryWriteAsParenthesesString(destination, Bytes, out charsWritten),
            'X' or 'x' => TryWriteAsHexadecimalString(destination, Bytes, out charsWritten),
            '5' => TryWriteAsId25(destination, Bytes, out charsWritten),
            '2' => TryWriteAsId22(destination, Bytes, out charsWritten),
            _ => throw new FormatException("Invalid UUID format."),
        };
    }
#elif NET6_0_OR_GREATER
    /// <summary>
    /// Tries to format the current instance into the provided character span.
    /// </summary>
    /// <param name="destination">The span in which to write.</param>
    /// <param name="charsWritten">When this method returns, contains the number of characters written into the span.</param>
    /// <param name="format">A read-only span containing the character representing one of the following specifiers that indicates the exact format to use when interpreting input: "N", "D", "B", "P", or "X".</param>
    /// <param name="provider">Not used.</param>
    /// <exception cref="NotImplementedException"></exception>
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider) {  // formatProvider is ignored
        if (format.Length > 1) { charsWritten = 0; return false; }

        var formatChar = (format.Length == 1) ? format[0] : 'D';
        return formatChar switch {  // treat uppercase and lowercase the same (compatibility with Guid ToFormat)
            'D' or 'd' => TryWriteAsDefaultString(destination, Bytes, out charsWritten),
            'N' or 'n' => TryWriteAsNoHypensString(destination, Bytes, out charsWritten),
            'B' or 'b' => TryWriteAsBracesString(destination, Bytes, out charsWritten),
            'P' or 'p' => TryWriteAsParenthesesString(destination, Bytes, out charsWritten),
            'X' or 'x' => TryWriteAsHexadecimalString(destination, Bytes, out charsWritten),
            '5' => TryWriteAsId25(destination, Bytes, out charsWritten),
            '2' => TryWriteAsId22(destination, Bytes, out charsWritten),
            _ => throw new FormatException("Invalid UUID format."),
        };
    }
#endif

    #endregion ISpanFormattable


    #region ISpanParsable<Uuid7>

    /// <summary>
    /// Returns UUID parsed from a given input.
    /// The following formats are supported: D, N, B, and P.
    /// </summary>
    /// <param name="s">Input.</param>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
    public static Uuid7 Parse(string s) {
        return Parse(s, provider: null);
    }

    /// <summary>
    /// Returns true if UUID was successfully parsed.
    /// The following formats are supported: D, N, B, and P.
    /// </summary>
    /// <param name="s">Input.</param>
    /// <param name="result">When this method returns, contains the result of successfully parsing or an undefined value on failure.</param>
#if NET6_0_OR_GREATER
    public static bool TryParse([NotNullWhen(true)] string? s, [MaybeNullWhen(false)] out Uuid7 result) {
#else
    public static bool TryParse(string? s, out Uuid7 result) {
#endif
        return TryParse(s, provider: null, out result);
    }

#if NET7_0_OR_GREATER

    /// <summary>
    /// Returns UUID parsed from a given input.
    /// </summary>
    /// <param name="s">Input.</param>
    /// <param name="provider">Not used.</param>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
    public static Uuid7 Parse(ReadOnlySpan<char> s, IFormatProvider? provider) {
        if (TryParse(s, provider, out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }

    /// <summary>
    /// Returns true if UUID was successfully parsed.
    /// </summary>
    /// <param name="s">Input.</param>
    /// <param name="provider">Not used.</param>
    /// <param name="result">When this method returns, contains the result of successfully parsing or an undefined value on failure.</param>
    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, [MaybeNullWhen(false)] out Uuid7 result) {
        return TryParseAsString(s, out result);
    }
#endif

    /// <summary>
    /// Returns UUID parsed from a given input.
    /// </summary>
    /// <param name="s">Input.</param>
    /// <param name="provider">Not used.</param>
    /// <exception cref="ArgumentNullException">Input cannot be null.</exception>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
    public static Uuid7 Parse(string s, IFormatProvider? provider) {
        if (s is null) { throw new ArgumentNullException(nameof(s), "Input cannot be null."); }
        if (TryParse(s, provider, out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }

    /// <summary>
    /// Returns true if UUID was successfully parsed.
    /// </summary>
    /// <param name="s">Input.</param>
    /// <param name="provider">Not used.</param>
    /// <param name="result">When this method returns, contains the result of successfully parsing or an undefined value on failure.</param>
#if NET6_0_OR_GREATER
    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out Uuid7 result) {
        if (s == null) { result = Empty; return false; }
        return TryParseAsString(s.AsSpan(), out result);
    }
#else
    public static bool TryParse(string? s, IFormatProvider? provider, out Uuid7 result) {
        if (s == null) { result = Empty; return false; }
        return TryParseAsString(s.ToCharArray(), out result);
    }
#endif

    #endregion ISpanParsable<Uuid7>

    #region Helpers

    private const long UnixEpochMilliseconds = 62_135_596_800_000;
    private const long TicksPerMillisecond = 10_000;

#if NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveOptimization)]
    private static int CompareArrays(ReadOnlySpan<byte> buffer1, ReadOnlySpan<byte> buffer2) {
        if ((buffer1 != null) && (buffer2 != null)) {  // protecting against EF or similar API that uses reflection (https://github.com/medo64/Medo.Uuid7/issues/1)
            return buffer1.SequenceCompareTo(buffer2);
#else
    private static int CompareArrays(byte[] buffer1, byte[] buffer2) {
        if ((buffer1 != null) && (buffer2 != null)) {
            var comparer = Comparer<byte>.Default;
            for (int i = 0; i < buffer1.Length; i++) {
                if (comparer.Compare(buffer1[i], buffer2[i]) < 0) { return -1; }
                if (comparer.Compare(buffer1[i], buffer2[i]) > 0) { return +1; }
            }
#endif
#if NET8_0_OR_GREATER
        } else if (buffer1 != null) {
            if (buffer1.IndexOfAnyExcept((byte)0) >= 0) { return +1; }
        } else if (buffer2 != null) {
            if (buffer2.IndexOfAnyExcept((byte)0) >= 0) { return -1; }
        }
#else
        } else if (buffer1 != null) {
            for (int i = 0; i < buffer1.Length; i++) {
                if (buffer1[i] != 0) { return +1; }
            }
        } else if (buffer2 != null) {
            for (int i = 0; i < buffer2.Length; i++) {
                if (buffer2[i] != 0) { return -1; }
            }
        }
#endif
        return 0;  // object are equal
    }

    private static readonly RandomNumberGenerator Random = RandomNumberGenerator.Create();  // needed due to .NET Standard 2.0
#if !UUID7_NO_RANDOM_BUFFER
    private const int RandomBufferSize = 2048;
    private static readonly ThreadLocal<byte[]> RandomBuffer = new(() => {
#if !NETSTANDARD
        return GC.AllocateArray<byte>(RandomBufferSize, pinned: true);
#else  // no pinning in case of .NET Standard (legacy support)
        return new byte[RandomBufferSize];
#endif
    });
    private static readonly ThreadLocal<int> RandomBufferIndex = new(() => RandomBufferSize);  // first call needs to fill buffer no matter what
#endif

#if NET6_0_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static void GetRandomBytes(ref byte[] bytes, int offset, int count) {
#if !UUID7_NO_RANDOM_BUFFER
        var buffer = RandomBuffer.Value!;
        var bufferIndex = RandomBufferIndex.Value;

        if (unchecked(bufferIndex + count) > RandomBufferSize) {
            var leftover = unchecked(RandomBufferSize - bufferIndex);
            Buffer.BlockCopy(buffer, bufferIndex, bytes, offset, leftover);  // make sure to use all bytes
            offset = unchecked(offset + leftover);
            count = unchecked(count - leftover);

            Random.GetBytes(buffer);
            bufferIndex = 0;
        }

        Buffer.BlockCopy(buffer, bufferIndex, bytes, offset, count);
        RandomBufferIndex.Value = unchecked(bufferIndex + count);
#else
        Random.GetBytes(bytes, offset, count);
#endif
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET6_0_OR_GREATER
    private static bool TryWriteAsDefaultString(Span<char> destination, ReadOnlySpan<byte> bytes, out int charsWritten) {
#else
    private static bool TryWriteAsDefaultString(char[] destination, byte[] bytes, out int charsWritten) {
#endif
        if (destination.Length < 36) { charsWritten = 0; return false; }

        if (bytes == null) { bytes = MinValue.Bytes; }

        (destination[0], destination[1]) = ToTwoHexBytes(bytes[0]);
        (destination[2], destination[3]) = ToTwoHexBytes(bytes[1]);
        (destination[4], destination[5]) = ToTwoHexBytes(bytes[2]);
        (destination[6], destination[7]) = ToTwoHexBytes(bytes[3]);
        destination[8] = '-';
        (destination[9], destination[10]) = ToTwoHexBytes(bytes[4]);
        (destination[11], destination[12]) = ToTwoHexBytes(bytes[5]);
        destination[13] = '-';
        (destination[14], destination[15]) = ToTwoHexBytes(bytes[6]);
        (destination[16], destination[17]) = ToTwoHexBytes(bytes[7]);
        destination[18] = '-';
        (destination[19], destination[20]) = ToTwoHexBytes(bytes[8]);
        (destination[21], destination[22]) = ToTwoHexBytes(bytes[9]);
        destination[23] = '-';
        (destination[24], destination[25]) = ToTwoHexBytes(bytes[10]);
        (destination[26], destination[27]) = ToTwoHexBytes(bytes[11]);
        (destination[28], destination[29]) = ToTwoHexBytes(bytes[12]);
        (destination[30], destination[31]) = ToTwoHexBytes(bytes[13]);
        (destination[32], destination[33]) = ToTwoHexBytes(bytes[14]);
        (destination[34], destination[35]) = ToTwoHexBytes(bytes[15]);

        charsWritten = 36;
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET6_0_OR_GREATER
    private static bool TryWriteAsNoHypensString(Span<char> destination, ReadOnlySpan<byte> bytes, out int charsWritten) {
#else
    private static bool TryWriteAsNoHypensString(char[] destination, byte[] bytes, out int charsWritten) {
#endif
        if (destination.Length < 32) { charsWritten = 0; return false; }

        if (bytes == null) { bytes = MinValue.Bytes; }

        (destination[0], destination[1]) = ToTwoHexBytes(bytes[0]);
        (destination[2], destination[3]) = ToTwoHexBytes(bytes[1]);
        (destination[4], destination[5]) = ToTwoHexBytes(bytes[2]);
        (destination[6], destination[7]) = ToTwoHexBytes(bytes[3]);
        (destination[8], destination[9]) = ToTwoHexBytes(bytes[4]);
        (destination[10], destination[11]) = ToTwoHexBytes(bytes[5]);
        (destination[12], destination[13]) = ToTwoHexBytes(bytes[6]);
        (destination[14], destination[15]) = ToTwoHexBytes(bytes[7]);
        (destination[16], destination[17]) = ToTwoHexBytes(bytes[8]);
        (destination[18], destination[19]) = ToTwoHexBytes(bytes[9]);
        (destination[20], destination[21]) = ToTwoHexBytes(bytes[10]);
        (destination[22], destination[23]) = ToTwoHexBytes(bytes[11]);
        (destination[24], destination[25]) = ToTwoHexBytes(bytes[12]);
        (destination[26], destination[27]) = ToTwoHexBytes(bytes[13]);
        (destination[28], destination[29]) = ToTwoHexBytes(bytes[14]);
        (destination[30], destination[31]) = ToTwoHexBytes(bytes[15]);

        charsWritten = 32;
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET6_0_OR_GREATER
    private static bool TryWriteAsBracesString(Span<char> destination, ReadOnlySpan<byte> bytes, out int charsWritten) {
#else
    private static bool TryWriteAsBracesString(char[] destination, byte[] bytes, out int charsWritten) {
#endif
        if (destination.Length < 38) { charsWritten = 0; return false; }

        if (bytes == null) { bytes = MinValue.Bytes; }

        destination[0] = '{';
        (destination[1], destination[2]) = ToTwoHexBytes(bytes[0]);
        (destination[3], destination[4]) = ToTwoHexBytes(bytes[1]);
        (destination[5], destination[6]) = ToTwoHexBytes(bytes[2]);
        (destination[7], destination[8]) = ToTwoHexBytes(bytes[3]);
        destination[9] = '-';
        (destination[10], destination[11]) = ToTwoHexBytes(bytes[4]);
        (destination[12], destination[13]) = ToTwoHexBytes(bytes[5]);
        destination[14] = '-';
        (destination[15], destination[16]) = ToTwoHexBytes(bytes[6]);
        (destination[17], destination[18]) = ToTwoHexBytes(bytes[7]);
        destination[19] = '-';
        (destination[20], destination[21]) = ToTwoHexBytes(bytes[8]);
        (destination[22], destination[23]) = ToTwoHexBytes(bytes[9]);
        destination[24] = '-';
        (destination[25], destination[26]) = ToTwoHexBytes(bytes[10]);
        (destination[27], destination[28]) = ToTwoHexBytes(bytes[11]);
        (destination[29], destination[30]) = ToTwoHexBytes(bytes[12]);
        (destination[31], destination[32]) = ToTwoHexBytes(bytes[13]);
        (destination[33], destination[34]) = ToTwoHexBytes(bytes[14]);
        (destination[35], destination[36]) = ToTwoHexBytes(bytes[15]);
        destination[37] = '}';

        charsWritten = 38;
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET6_0_OR_GREATER
    private static bool TryWriteAsParenthesesString(Span<char> destination, ReadOnlySpan<byte> bytes, out int charsWritten) {
#else
    private static bool TryWriteAsParenthesesString(char[] destination, byte[] bytes, out int charsWritten) {
#endif
        if (destination.Length < 38) { charsWritten = 0; return false; }

        if (bytes == null) { bytes = MinValue.Bytes; }

        destination[0] = '(';
        (destination[1], destination[2]) = ToTwoHexBytes(bytes[0]);
        (destination[3], destination[4]) = ToTwoHexBytes(bytes[1]);
        (destination[5], destination[6]) = ToTwoHexBytes(bytes[2]);
        (destination[7], destination[8]) = ToTwoHexBytes(bytes[3]);
        destination[9] = '-';
        (destination[10], destination[11]) = ToTwoHexBytes(bytes[4]);
        (destination[12], destination[13]) = ToTwoHexBytes(bytes[5]);
        destination[14] = '-';
        (destination[15], destination[16]) = ToTwoHexBytes(bytes[6]);
        (destination[17], destination[18]) = ToTwoHexBytes(bytes[7]);
        destination[19] = '-';
        (destination[20], destination[21]) = ToTwoHexBytes(bytes[8]);
        (destination[22], destination[23]) = ToTwoHexBytes(bytes[9]);
        destination[24] = '-';
        (destination[25], destination[26]) = ToTwoHexBytes(bytes[10]);
        (destination[27], destination[28]) = ToTwoHexBytes(bytes[11]);
        (destination[29], destination[30]) = ToTwoHexBytes(bytes[12]);
        (destination[31], destination[32]) = ToTwoHexBytes(bytes[13]);
        (destination[33], destination[34]) = ToTwoHexBytes(bytes[14]);
        (destination[35], destination[36]) = ToTwoHexBytes(bytes[15]);
        destination[37] = ')';

        charsWritten = 38;
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET6_0_OR_GREATER
    private static bool TryWriteAsHexadecimalString(Span<char> destination, ReadOnlySpan<byte> bytes, out int charsWritten) {
#else
    private static bool TryWriteAsHexadecimalString(char[] destination, byte[] bytes, out int charsWritten) {
#endif
        if (destination.Length < 68) { charsWritten = 0; return false; }

        if (bytes == null) { bytes = MinValue.Bytes; }

        (destination[0], destination[1], destination[2]) = ('{', '0', 'x');
        (destination[3], destination[4]) = ToTwoHexBytes(bytes[0]);
        (destination[5], destination[6]) = ToTwoHexBytes(bytes[1]);
        (destination[7], destination[8]) = ToTwoHexBytes(bytes[2]);
        (destination[9], destination[10]) = ToTwoHexBytes(bytes[3]);
        (destination[11], destination[12], destination[13]) = (',', '0', 'x');
        (destination[14], destination[15]) = ToTwoHexBytes(bytes[4]);
        (destination[16], destination[17]) = ToTwoHexBytes(bytes[5]);
        (destination[18], destination[19], destination[20]) = (',', '0', 'x');
        (destination[21], destination[22]) = ToTwoHexBytes(bytes[6]);
        (destination[23], destination[24]) = ToTwoHexBytes(bytes[7]);
        (destination[25], destination[26], destination[27], destination[28]) = (',', '{', '0', 'x');
        (destination[29], destination[30]) = ToTwoHexBytes(bytes[8]);
        (destination[31], destination[32], destination[33]) = (',', '0', 'x');
        (destination[34], destination[35]) = ToTwoHexBytes(bytes[9]);
        (destination[36], destination[37], destination[38]) = (',', '0', 'x');
        (destination[39], destination[40]) = ToTwoHexBytes(bytes[10]);
        (destination[41], destination[42], destination[43]) = (',', '0', 'x');
        (destination[44], destination[45]) = ToTwoHexBytes(bytes[11]);
        (destination[46], destination[47], destination[48]) = (',', '0', 'x');
        (destination[49], destination[50]) = ToTwoHexBytes(bytes[12]);
        (destination[51], destination[52], destination[53]) = (',', '0', 'x');
        (destination[54], destination[55]) = ToTwoHexBytes(bytes[13]);
        (destination[56], destination[57], destination[58]) = (',', '0', 'x');
        (destination[59], destination[60]) = ToTwoHexBytes(bytes[14]);
        (destination[61], destination[62], destination[63]) = (',', '0', 'x');
        (destination[64], destination[65]) = ToTwoHexBytes(bytes[15]);
        (destination[66], destination[67]) = ('}', '}');

        charsWritten = 68;
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET6_0_OR_GREATER
    private static bool TryWriteAsId22(Span<char> destination, ReadOnlySpan<byte> bytes, out int charsWritten) {
#else
    private static bool TryWriteAsId22(char[] destination, byte[] bytes, out int charsWritten) {
#endif
        if (destination.Length < 22) { charsWritten = 0; return false; }

        if (bytes == null) { bytes = MinValue.Bytes; }

#if NET6_0_OR_GREATER
        var number = new BigInteger(bytes, isUnsigned: true, isBigEndian: true);
#else
        var bytesEx = new byte[17];
        Buffer.BlockCopy(bytes, 0, bytesEx, 1, 16);
        if (BitConverter.IsLittleEndian) { Array.Reverse(bytesEx); }
        var number = new BigInteger(bytesEx);
#endif
        for (var i = 21; i >= 0; i--) {
            number = BigInteger.DivRem(number, Base58Modulo, out var remainder);
            destination[i] = Base58Alphabet[(int)remainder];
        }

        charsWritten = 22;
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if NET6_0_OR_GREATER
    private static bool TryWriteAsId25(Span<char> destination, ReadOnlySpan<byte> bytes, out int charsWritten) {
#else
    private static bool TryWriteAsId25(char[] destination, byte[] bytes, out int charsWritten) {
#endif
        if (destination.Length < 25) { charsWritten = 0; return false; }

        if (bytes == null) { bytes = MinValue.Bytes; }

#if NET6_0_OR_GREATER
        var number = new BigInteger(bytes, isUnsigned: true, isBigEndian: true);
#else
        var bytesEx = new byte[17];
        Buffer.BlockCopy(bytes, 0, bytesEx, 1, 16);
        if (BitConverter.IsLittleEndian) { Array.Reverse(bytesEx); }
        var number = new BigInteger(bytesEx);
#endif
        for (var i = 24; i >= 0; i--) {
            number = BigInteger.DivRem(number, Base35Modulo, out var remainder);
            destination[i] = Base35Alphabet[(int)remainder];
        }

        charsWritten = 25;
        return true;
    }

    private static readonly BigInteger Base16Modulo = 16;
    private static readonly char[] Base16Alphabet = [
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
    ];
    private static readonly Lazy<Dictionary<char, BigInteger>> Base16AlphabetDict = new(() => {
        var dict = new Dictionary<char, BigInteger>(Base16Alphabet.Length);
        for (var i = 0; i < Base16Alphabet.Length; i++) {
            var ch = Base16Alphabet[i];
            dict.Add(ch, i);
            if (char.IsLetter(ch)) { dict.Add(char.ToUpperInvariant(ch), i); }  // case-insensitive
        }
        return dict;
    });

#if NET6_0_OR_GREATER
    private static bool TryParseAsString(ReadOnlySpan<char> source, out Uuid7 result) {
#else
    private static bool TryParseAsString(char[] source, out Uuid7 result) {
#endif
        var alphabetDict = Base16AlphabetDict.Value;
        var count = 0;
        var number = new BigInteger();
        foreach (var ch in source) {
            if (alphabetDict.TryGetValue(ch, out var offset)) {
                number = BigInteger.Multiply(number, Base16Modulo);
                number = BigInteger.Add(number, offset);
                count++;
            }
        }
        if (count != 32) { result = Uuid7.Empty; return false; }

#if NET6_0_OR_GREATER
        int byteCount = number.GetByteCount(isUnsigned: true);
        Span<byte> buffer = stackalloc byte[byteCount];
        number.TryWriteBytes(buffer, out _, isUnsigned: true, isBigEndian: true);

        if (buffer.Length < 16) {
            Span<byte> newBuffer = stackalloc byte[16];
            buffer.CopyTo(newBuffer[(16 - buffer.Length)..]);
            buffer = newBuffer;
        }
#else
        byte[] numberBytes = number.ToByteArray();
        if (BitConverter.IsLittleEndian) { Array.Reverse(numberBytes); }
        var buffer = new byte[16];
        if (numberBytes.Length > 16) {
            Buffer.BlockCopy(numberBytes, numberBytes.Length - 16, buffer, 0, 16);
        } else {
            Buffer.BlockCopy(numberBytes, 0, buffer, 16 - numberBytes.Length, numberBytes.Length);
        }
        if (buffer.Length < 16) {
            var newBuffer = new byte[16];
            Buffer.BlockCopy(buffer, 0, newBuffer, 16 - buffer.Length, buffer.Length);
            buffer = newBuffer;
        }
#endif

        result = new Uuid7(buffer);
        return true;
    }

    private static readonly BigInteger Base35Modulo = 35;
    private static readonly char[] Base35Alphabet = [
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
        'k', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z'
    ];
    private static readonly Lazy<Dictionary<char, BigInteger>> Base35AlphabetDict = new(() => {
        var dict = new Dictionary<char, BigInteger>(Base35Alphabet.Length);
        for (var i = 0; i < Base35Alphabet.Length; i++) {
            var ch = Base35Alphabet[i];
            dict.Add(ch, i);
            if (char.IsLetter(ch)) {  // case-insensitive
                dict.Add(char.ToUpperInvariant(ch), i);
            }
        }
        return dict;
    });

#if NET6_0_OR_GREATER
    private static bool TryParseAsId25(ReadOnlySpan<char> source, out Uuid7 result) {
#else
    private static bool TryParseAsId25(char[] source, out Uuid7 result) {
#endif
        var alphabetDict = Base35AlphabetDict.Value;
        var count = 0;
        var number = new BigInteger();
        foreach (var ch in source) {
            if (alphabetDict.TryGetValue(ch, out var offset)) {
                number = BigInteger.Multiply(number, Base35Modulo);
                number = BigInteger.Add(number, offset);
                count++;
            }
        }
        if (count != 25) { result = Empty; return false; }

#if NET6_0_OR_GREATER
        int byteCount = number.GetByteCount(isUnsigned: true);
        Span<byte> buffer = stackalloc byte[byteCount];
        number.TryWriteBytes(buffer, out _, isUnsigned: true, isBigEndian: true);

        if (buffer.Length < 16) {
            Span<byte> newBuffer = stackalloc byte[16];
            buffer.CopyTo(newBuffer[(16 - buffer.Length)..]);
            buffer = newBuffer;
        }
#else
        byte[] numberBytes = number.ToByteArray();
        if (BitConverter.IsLittleEndian) { Array.Reverse(numberBytes); }
        var buffer = new byte[16];
        if (numberBytes.Length > 16) {
            Buffer.BlockCopy(numberBytes, numberBytes.Length - 16, buffer, 0, 16);
        } else {
            Buffer.BlockCopy(numberBytes, 0, buffer, 16 - numberBytes.Length, numberBytes.Length);
        }

        if (buffer.Length < 16) {
            var newBuffer = new byte[16];
            Buffer.BlockCopy(buffer, 0, newBuffer, 16 - buffer.Length, buffer.Length);
            buffer = newBuffer;
        }
#endif

        result = new Uuid7(buffer);
        return true;
    }

    private static readonly BigInteger Base58Modulo = 58;
    private static readonly char[] Base58Alphabet = [
        '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',
        'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L',
        'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
        'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'm', 'n', 'o', 'p', 'q', 'r',
        's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
    ];
    private static readonly Lazy<Dictionary<char, BigInteger>> Base58AlphabetDict = new(() => {
        var dict = new Dictionary<char, BigInteger>(Base58Alphabet.Length);
        for (var i = 0; i < Base58Alphabet.Length; i++) {
            dict.Add(Base58Alphabet[i], i);
        }
        return dict;
    });

#if NET6_0_OR_GREATER
    private static bool TryParseAsId22(ReadOnlySpan<char> source, out Uuid7 result) {
#else
    private static bool TryParseAsId22(char[] source, out Uuid7 result) {
#endif
        var alphabetDict = Base58AlphabetDict.Value;
        var count = 0;
        var number = new BigInteger();
        foreach (var ch in source) {
            if (alphabetDict.TryGetValue(ch, out var offset)) {
                number = BigInteger.Multiply(number, Base58Modulo);
                number = BigInteger.Add(number, offset);
                count++;
            }
        }
        if (count != 22) { result = Empty; return false; }

#if NET6_0_OR_GREATER
        int byteCount = number.GetByteCount(isUnsigned: true);
        Span<byte> buffer = stackalloc byte[byteCount];
        number.TryWriteBytes(buffer, out _, isUnsigned: true, isBigEndian: true);

        if (buffer.Length < 16) {
            Span<byte> newBuffer = stackalloc byte[16];
            buffer.CopyTo(newBuffer[(16 - buffer.Length)..]);
            buffer = newBuffer;
        }
#else
        byte[] numberBytes = number.ToByteArray();
        if (BitConverter.IsLittleEndian) { Array.Reverse(numberBytes); }
        var buffer = new byte[16];
        if (numberBytes.Length > 16) {
            Buffer.BlockCopy(numberBytes, numberBytes.Length - 16, buffer, 0, 16);
        } else {
            Buffer.BlockCopy(numberBytes, 0, buffer, 16 - numberBytes.Length, numberBytes.Length);
        }

        if (buffer.Length < 16) {
            var newBuffer = new byte[16];
            Buffer.BlockCopy(buffer, 0, newBuffer, 16 - buffer.Length, buffer.Length);
            buffer = newBuffer;
        }
#endif

        result = new Uuid7(buffer);
        return true;
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static (char, char) ToTwoHexBytes(byte b) {
        return (Base16Alphabet[b >> 4], Base16Alphabet[b & 0x0F]);
    }

    #endregion Helpers

}
