/* Josip Medved <jmedved@jmedved.com> * www.medo64.com * MIT License */

namespace Medo;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

#if NET6_0_OR_GREATER
using System.Diagnostics.CodeAnalysis;
#endif

#if NET7_0_OR_GREATER
using System.Runtime.Intrinsics;
#endif


/// <summary>
/// Implements UUID version 7 as defined in RFC draft at
/// https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html.
/// </summary>
[DebuggerDisplay("{ToString(),nq}")]
[StructLayout(LayoutKind.Sequential)]
public readonly partial struct Uuid7
    : IComparable<Guid>
    , IComparable<Uuid7>
    , IEquatable<Uuid7>
    , IEquatable<Guid>
    , IFormattable
#if NET6_0_OR_GREATER
    , ISpanFormattable
#endif
#if NET7_0_OR_GREATER
    , ISpanParsable<Uuid7>
#endif
{

    /// <summary>
    /// Creates a new version 7 UUID.
    /// Sequencing is done on a per-thread basis. This means that each thread
    /// maintains a separate counter, and thus sequences generated by different
    /// threads might overlap. Please note that this overlap is no  worse than
    /// what one would expect if the code was executing on a different computer.
    /// However, if strict sequencing is required, please use the static
    /// NewUuid7() method that guarantees this behavior.
    /// </summary>
    public Uuid7() {
        Bytes = new byte[16];
        FillBytes7(ref Bytes, DateTime.UtcNow.Ticks, ref PerThreadLastMillisecond, ref PerThreadMillisecondCounter, ref PerThreadMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
    }

    /// <summary>
    /// Creates a new instance from given byte array.
    /// No check if array is version 7 UUID is made.
    /// </summary>
    /// <exception cref="ArgumentNullException">Buffer cannot be null.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Buffer must be exactly 16 bytes in length.</exception>
    public Uuid7(byte[] buffer) {
        if (buffer == null) { throw new ArgumentNullException(nameof(buffer), "Buffer cannot be null."); }
        if (buffer.Length != 16) { throw new ArgumentOutOfRangeException(nameof(buffer), "Buffer must be exactly 16 bytes in length."); }
        Bytes = new byte[16];
        Buffer.BlockCopy(buffer, 0, Bytes, 0, 16);
    }

#if NET6_0_OR_GREATER
    /// <summary>
    /// Creates a new instance from given read-only byte span.
    /// No check if array is version 7 UUID is made.
    /// </summary>
    /// <exception cref="ArgumentNullException">Span cannot be null.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Span must be exactly 16 bytes in length.</exception>
    public Uuid7(ReadOnlySpan<byte> span) {
        if (span.Length != 16) { throw new ArgumentOutOfRangeException(nameof(span), "Span must be exactly 16 bytes in length."); }
        Bytes = new byte[16];
        span.CopyTo(Bytes);
    }
#endif

    /// <summary>
    /// Creates a new instance from given GUID bytes.
    /// No check if GUID is version 7 UUID is made.
    /// </summary>
    /// <param name="guid">Guid.</param>
    public Uuid7(Guid guid)
        : this(guid, bigEndian: IsBigEndian) {
    }

    /// <summary>
    /// Creates a new instance from given GUID bytes.
    /// No check if GUID is version 7 UUID is made.
    /// </summary>
    /// <param name="guid">Guid.</param>
    /// <param name="bigEndian">If true, input will be assumed to be in a big-endian format.</param>
    public Uuid7(Guid guid, bool bigEndian) {
        if (IsBigEndian != bigEndian) {
            Bytes = guid.ToByteArray();
        } else {
            Bytes = ReverseGuidEndianess(guid.ToByteArray());
        }
    }


    /// <summary>
    /// Creates a new instance with a given byte array.
    /// No check if array is version 7 UUID is made.
    /// No check for array length is made.
    /// </summary>
    private Uuid7(ref byte[] buffer) {
        Bytes = buffer;
    }

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
    private readonly byte[] Bytes;


    /// <summary>
    /// Gets the value of the version field.
    /// </summary>
    public int Version {
        get {
            if (Bytes == null) { return 0; }
            return (Bytes[6] & 0xF0) >> 4;
        }
    }

    /// <summary>
    /// Gets the value of the variant field.
    /// Please note the variant returned is 4-bit value as defined in RFC9562,
    /// section 4.1. In practice, this means that version 7 values can have values
    /// 8-11 (8-B, in hexadecimal).
    /// </summary>
    public int Variant {
        get {
            if (Bytes == null) { return 0; }
            return Bytes[8] >> 4;
        }
    }


    #region Static

    /// <summary>
    /// A read-only instance of the Uuid7 structure whose value is all zeros.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 MinValue = new(new byte[16]);

    /// <summary>
    /// A read-only instance of the Uuid7 structure whose value is all ones.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 MaxValue = new([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]);

    /// <summary>
    /// A read-only instance of the Uuid7 structure whose value is all zeros.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 Empty = MinValue;

    /// <summary>
    /// A read-only instance of the Uuid7 structure whose value is all ones.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 AllBitsSet = MaxValue;


    /// <summary>
    /// Returns a new UUID version 7.
    /// This method is thread-safe.
    /// For higher multi-threaded performance, consider using new Uuid7()
    /// instead, as it utilizes per-thread counters. While this doesn't
    /// guarantee strict sequencing, it provides no worse results than
    /// generating UUIDs on multiple computers.
    /// </summary>
    public static Uuid7 NewUuid7() {
        var bytes = new byte[16];
        lock (NonThreadedSyncRoot) {
            FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
        }
        return new Uuid7(ref bytes);
    }

    /// <summary>
    /// Returns a new UUID version 7 with a specific timestamp.
    /// This is not recommended for general use since it doesn't offer the same collision protections as the default NewUuid7() method.
    /// This method is thread-safe.
    /// </summary>
    public static Uuid7 NewUuid7(DateTimeOffset timestamp) {
        var bytes = new byte[16];
        long lastMillisecond = 0;
        long millisecondCounter = 0;
        uint monotonicCounter = 0;
        FillBytes7(ref bytes, timestamp.UtcTicks, ref lastMillisecond, ref millisecondCounter, ref monotonicCounter);
        return new Uuid7(ref bytes);
    }

    /// <summary>
    /// Returns new UUID version 4.
    /// This method is thread-safe.
    /// </summary>
    public static Uuid7 NewUuid4() {
        var bytes = new byte[16];
        FillBytes4(ref bytes);
        return new Uuid7(ref bytes);
    }

    /// <summary>
    /// Returns an equivalent System.Guid of a UUID version 7.
    /// This method is thread-safe.
    /// </summary>
    public static Guid NewGuid() {
        return NewGuid(bigEndian: IsBigEndian);
    }

    /// <summary>
    /// Returns an equivalent System.Guid of a UUID version 7.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="bigEndian">If true, input will be assumed to be in a big-endian format.</param>
    public static Guid NewGuid(bool bigEndian) {
        var bytes = new byte[16];
        lock (NonThreadedSyncRoot) {
            FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
        }
        if (IsBigEndian == bigEndian) { ReverseGuidEndianess(ref bytes); }
        return new Guid(bytes);
    }


    /// <summary>
    /// Returns a System.Guid of a UUID version 7 suitable for insertion into a
    /// Microsoft SQL database. This should be used only when working with MS
    /// SQL Server and not with any other databases as byte ordering is
    /// different than usual. If you are using Uuid7 in a mixed database
    /// environment, use the NewUuid7() method instead.
    /// This method is thread-safe.
    /// </summary>
    public static Guid NewMsSqlUniqueIdentifier() {
        var bytes = new byte[16];
        lock (NonThreadedSyncRoot) {
            FillBytes7MsSql(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
        }
        return new Guid(bytes);
    }


    /// <summary>
    /// Fills a span with version 7 UUIDs.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void Fill(Span<Uuid7> data) {
#else
    public static void Fill(Uuid7[] data) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                data[i] = new Uuid7(ref bytes);
            }
        }
    }

    /// <summary>
    /// Fills a span with version 7 UUIDs.
    /// All UUIDs are created with the same timestamp.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <param name="timestamp">Millisecond time for when UUIDs are to be created.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void Fill(Span<Uuid7> data, DateTimeOffset timestamp) {
#else
    public static void Fill(Uuid7[] data, DateTimeOffset timestamp) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        long lastMillisecond = 0;
        long millisecondCounter = 0;
        uint monotonicCounter = 0;
        for (var i = 0; i < data.Length; i++) {
            var bytes = new byte[16];
            FillBytes7(ref bytes, timestamp.UtcTicks, ref lastMillisecond, ref millisecondCounter, ref monotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
            data[i] = new Uuid7(ref bytes);
        }
    }

    /// <summary>
    /// Fills a span with version 4 UUIDs.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillUuid4(Span<Uuid7> data) {
#else
    public static void FillUuid4(Uuid7[] data) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        for (var i = 0; i < data.Length; i++) {
            var bytes = new byte[16];
            FillBytes4(ref bytes);
            data[i] = new Uuid7(ref bytes);
        }
    }

    /// <summary>
    /// Fills a span with System.Guid elements.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillGuid(Span<Guid> data) {
#else
    public static void FillGuid(Guid[] data) {
#endif
        FillGuid(data, bigEndian: IsBigEndian);
    }

    /// <summary>
    /// Fills a span with System.Guid elements.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <param name="bigEndian">If true, input will be assumed to be in a big-endian format.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillGuid(Span<Guid> data, bool bigEndian) {
#else
    public static void FillGuid(Guid[] data, bool bigEndian) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        var shouldReverse = (IsBigEndian == bigEndian);
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                if (shouldReverse) { ReverseGuidEndianess(ref bytes); }
                data[i] = new Guid(bytes);
            }
        }
    }

    /// <summary>
    /// Fills a span with version 7 UUIDs converted to System.Guid and suitable
    /// for insertion into a Microsoft SQL database. This should be used only
    /// when working with MS SQL Server and not with any other databases as byte
    /// ordering is different than usual. If you are using Uuid7 in a mixed
    /// database environment, use the FillUuid7() method instead.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillMsSqlUniqueIdentifier(Span<Guid> data) {
#else
    public static void FillMsSqlUniqueIdentifier(Guid[] data) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7MsSql(ref bytes, DateTime.UtcNow.Ticks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                data[i] = new Guid(bytes);
            }
        }
    }

    /// <summary>
    /// Fills a span with version 7 UUIDs converted to System.Guid and suitable
    /// for insertion into a Microsoft SQL database. This should be used only
    /// when working with MS SQL Server and not with any other databases as byte
    /// ordering is different than usual. If you are using Uuid7 in a mixed
    /// database environment, use the FillUuid7() method instead.
    /// All UUIDs are created with the same timestamp.
    /// This method is thread-safe.
    /// </summary>
    /// <param name="data">The span to fill.</param>
    /// <param name="timestamp">Millisecond time for when UUIDs are to be created.</param>
    /// <exception cref="ArgumentNullException">Data cannot be null.</exception>
#if NET6_0_OR_GREATER
    public static void FillMsSqlUniqueIdentifier(Span<Guid> data, DateTimeOffset timestamp) {
#else
    public static void FillMsSqlUniqueIdentifier(Guid[] data, DateTimeOffset timestamp) {
        if (data == null) { throw new ArgumentNullException(nameof(data), "Data cannot be null."); }
#endif
        lock (NonThreadedSyncRoot) {
            for (var i = 0; i < data.Length; i++) {
                var bytes = new byte[16];
                FillBytes7MsSql(ref bytes, timestamp.UtcTicks, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);  // DateTime is a smidgen faster than DateTimeOffset
                data[i] = new Guid(bytes);
            }
        }
    }

    #endregion Static


    /// <summary>
    /// Returns current UUID as an equivalent System.Guid.
    /// </summary>
    public Guid ToGuid() {
        return ToGuid(bigEndian: IsBigEndian);
    }

    /// <summary>
    /// Converts current UUID to an equivalent System.Guid.
    /// </summary>
    /// <param name="bigEndian">If true, input will be assumed to be in a big-endian format.</param>
    public Guid ToGuid(bool bigEndian) {
        if (Bytes == null) { return Guid.Empty; }
        if (BitConverter.IsLittleEndian == bigEndian) {
            return new Guid(  // faster than calling byte[] overload
                Bytes[3] << 24 | Bytes[2] << 16 | Bytes[1] << 8 | Bytes[0],
                (short)(Bytes[5] << 8 | Bytes[4]),
                (short)(Bytes[7] << 8 | Bytes[6]),
                Bytes[8], Bytes[9], Bytes[10], Bytes[11], Bytes[12], Bytes[13], Bytes[14], Bytes[15]
            );
        } else {
            return new Guid(  // and uses less allocations too
                Bytes[0] << 24 | Bytes[1] << 16 | Bytes[2] << 8 | Bytes[3],
                (short)(Bytes[4] << 8 | Bytes[5]),
                (short)(Bytes[6] << 8 | Bytes[7]),
                Bytes[8], Bytes[9], Bytes[10], Bytes[11], Bytes[12], Bytes[13], Bytes[14], Bytes[15]
            );
        }
    }


    /// <summary>
    /// Returns an array that contains UUID bytes.
    /// Always in big-endian order.
    /// </summary>
    public byte[] ToByteArray() {
        var copy = new byte[16];
        if (Bytes != null) { Buffer.BlockCopy(Bytes, 0, copy, 0, 16); }
        return copy;
    }

    /// <summary>
    /// Returns an array that contains UUID bytes.
    /// Enginaness of bytes refers to the first 8 bytes and their handling in
    /// Guid structure.
    /// </summary>
    /// <param name="bigEndian">If true, bytes will be in big-endian (natural) order.</param>
    public byte[] ToByteArray(bool bigEndian) {
        if (Bytes == null) { return Empty.ToByteArray(); }
        if (bigEndian) {
            var copy = new byte[16];
            Buffer.BlockCopy(Bytes, 0, copy, 0, 16);
            return copy;
        } else {
            return ReverseGuidEndianess(Bytes);
        }
    }

    /// <summary>
    /// Returns DateTime based on UUID v7 timestamp.
    /// Please note that only timestamp has only 1 millisecond resolution and random bits are lost.
    /// </summary>
    /// <exception cref="InvalidOperationException">UUID is not version 7.</exception>
    public DateTime ToDateTime() {
        if (Bytes == null) { return DateTime.MinValue; }
        if ((Bytes[6] & 0xF0) != 0x70) { throw new InvalidOperationException("UUID is not version 7."); }
        var unixMs = (long)Bytes[0] << 40 | (long)Bytes[1] << 32 | (long)Bytes[2] << 24 | (long)Bytes[3] << 16 | (long)Bytes[4] << 8 | Bytes[5];
        var ticks = (UnixEpochMilliseconds + unixMs) * TicksPerMillisecond;
        return new DateTime(ticks, DateTimeKind.Utc);
    }

    /// <summary>
    /// Returns DateTimeOffset based on UUID v7 timestamp.
    /// Please note that only timestamp has only 1 millisecond resolution and random bits are lost.
    /// </summary>
    /// <exception cref="InvalidOperationException">UUID is not version 7.</exception>
    public DateTimeOffset ToDateTimeOffset() {
        if (Bytes == null) { return DateTimeOffset.MinValue; }
        if ((Bytes[6] & 0xF0) != 0x70) { throw new InvalidOperationException("UUID is not version 7."); }
        var unixMs = (long)Bytes[0] << 40 | (long)Bytes[1] << 32 | (long)Bytes[2] << 24 | (long)Bytes[3] << 16 | (long)Bytes[4] << 8 | Bytes[5];
        var ticks = (UnixEpochMilliseconds + unixMs) * TicksPerMillisecond;
        return new DateTimeOffset(ticks, TimeSpan.Zero);
    }


#if NET6_0_OR_GREATER

    /// <summary>
    /// Tries to write the current instance into a span of bytes.
    /// </summary>
    /// <param name="destination">Destination span.</param>
    public bool TryWriteBytes(Span<byte> destination) {
        if (destination.Length < 16) { return false; }  // not enough bytes
        if (Bytes != null) {
            Bytes.CopyTo(destination);
        } else {
            MinValue.Bytes.CopyTo(destination);
        }
        return true;
    }

#endif


    #region String

    /// <summary>
    /// Returns UUID from given text representation.
    /// All characters not belonging to hexadecimal alphabet are ignored.
    /// Input must contain exactly 32 hexadecimal characters.
    /// The following formats are supported: D, N, B, and P.
    /// </summary>
    /// <param name="text">UUID text.</param>
    /// <exception cref="ArgumentNullException">Text cannot be null.</exception>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
    public static Uuid7 FromString(string text) {
        return Parse(text, provider: null);
    }


    /// <summary>
    /// Returns UUID representation in Id26 format.
    /// Id26 uses lexicographical sortable Base-32 dictionary with 2-bit modulo 2 Fletcher checksum.
    /// </summary>
    public string ToId26String() {
        return ToString(format: "6", formatProvider: null);
    }

    /// <summary>
    /// Returns UUID from given text representation.
    /// All characters not belonging to Id26 alphabet are ignored.
    /// Input must contain exactly 26 characters.
    /// </summary>
    /// <param name="id26Text">Id26 text.</param>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
#if NET6_0_OR_GREATER
    public static Uuid7 FromId26String(ReadOnlySpan<char> id26Text) {
        if (TryParseAsId26(id26Text, out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }
#else
    public static Uuid7 FromId26String(string id26Text) {
        if (id26Text == null) { throw new ArgumentNullException(nameof(id26Text), "Text cannot be null."); }
        if (TryParseAsId26(id26Text.ToCharArray(), out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }
#endif


    /// <summary>
    /// Returns UUID representation in Id25 format.
    /// Please note that while conversion is the same as one in
    /// https://github.com/stevesimmons/uuid7-csharp/, UUIDs are not fully
    /// compatible and thus not necessarily interchangeable.
    /// </summary>
    public string ToId25String() {
        return ToString(format: "5", formatProvider: null);
    }

    /// <summary>
    /// Returns UUID from given text representation.
    /// All characters not belonging to Id25 alphabet are ignored.
    /// Input must contain exactly 25 characters.
    /// </summary>
    /// <param name="id25Text">Id25 text.</param>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
#if NET6_0_OR_GREATER
    public static Uuid7 FromId25String(ReadOnlySpan<char> id25Text) {
        if (TryParseAsId25(id25Text, out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }
#else
    public static Uuid7 FromId25String(string id25Text) {
        if (id25Text == null) { throw new ArgumentNullException(nameof(id25Text), "Text cannot be null."); }
        if (TryParseAsId25(id25Text.ToCharArray(), out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }
#endif


    /// <summary>
    /// Returns UUID representation in Id22 format. This is base58 encoder
    /// using the same alphabet as bitcoin does.
    /// </summary>
    public string ToId22String() {
        return ToString(format: "2", formatProvider: null);
    }

    /// <summary>
    /// Returns UUID from given text representation.
    /// All characters not belonging to Id22 alphabet are ignored.
    /// Input must contain exactly 22 characters.
    /// </summary>
    /// <param name="id22Text">Id22 text.</param>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
#if NET6_0_OR_GREATER
    public static Uuid7 FromId22String(ReadOnlySpan<char> id22Text) {
        if (TryParseAsId22(id22Text, out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }
#else
    public static Uuid7 FromId22String(string id22Text) {
        if (id22Text == null) { throw new ArgumentNullException(nameof(id22Text), "Text cannot be null."); }
        if (TryParseAsId22(id22Text.ToCharArray(), out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }
#endif

    #endregion String


    #region Overrides

    /// <summary>
    /// Returns true if this instance is equal to a specified object.
    /// Object can be either Uuid7 or Guid.
    /// </summary>
    /// <param name="obj">An object to compare to this instance.</param>
#if NET6_0_OR_GREATER
    public override bool Equals([NotNullWhen(true)] object? obj) {
#else
    public override bool Equals(object? obj) {
#endif
        if (obj is Uuid7 uuid) {
            return CompareArrays(Bytes, uuid.Bytes) == 0;
        } else if (obj is Guid guid) {
            var guidBytes = guid.ToByteArray();
            ReverseGuidEndianess(ref guidBytes);
            return CompareArrays(Bytes, guidBytes) == 0;
        }
        return false;
    }

    /// <summary>
    /// Returns a hash code for the current object.
    /// </summary>
    public override int GetHashCode() {
        if (Bytes == null) { return 0; }
        var hc = ((Bytes[0] ^ Bytes[6] ^ Bytes[11] ^ Bytes[15]) << 24)
               | ((Bytes[1] ^ Bytes[7] ^ Bytes[10] ^ Bytes[14]) << 16)
               | ((Bytes[2] ^ Bytes[4] ^ Bytes[9] ^ Bytes[13]) << 8)
               | (Bytes[3] ^ Bytes[5] ^ Bytes[8] ^ Bytes[12]);
        return hc;  // just XOR individual ints - compatible with Guid implementation on LE platform
    }

    /// <summary>
    /// Returns a string that represents the current object.
    /// </summary>
    public override string ToString() {
        return ToString(format: null, formatProvider: null);
    }

    #endregion Overrides


    #region Operators

    /// <summary>
    /// Returns true if both operands are equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator ==(Uuid7 left, Uuid7 right) {
        return left.Equals(right);
    }

    /// <summary>
    /// Returns true if both operands are equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator ==(Uuid7 left, Guid right) {
        return left.Equals(right);
    }

    /// <summary>
    /// Returns true if both operands are equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator ==(Guid left, Uuid7 right) {
        return left.Equals(right);
    }


    /// <summary>
    /// Returns true if both operands are not equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator !=(Uuid7 left, Uuid7 right) {
        return !(left == right);
    }

    /// <summary>
    /// Returns true if both operands are not equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator !=(Uuid7 left, Guid right) {
        return !(left == right);
    }

    /// <summary>
    /// Returns true if both operands are not equal.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator !=(Guid left, Uuid7 right) {
        return !(left == right);
    }


    /// <summary>
    /// Returns true if left-hand operand is less than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <(Uuid7 left, Uuid7 right) {
        return left.CompareTo(right) < 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is less than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <(Uuid7 left, Guid right) {
        return left.CompareTo(right) < 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is less than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <(Guid left, Uuid7 right) {
        return left.CompareTo(right) < 0;
    }


    /// <summary>
    /// Returns true if left-hand operand is less than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <=(Uuid7 left, Uuid7 right) {
        return left.CompareTo(right) is < 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is less than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <=(Uuid7 left, Guid right) {
        return left.CompareTo(right) is < 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is less than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator <=(Guid left, Uuid7 right) {
        return left.CompareTo(right) is < 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >=(Uuid7 left, Uuid7 right) {
        return left.CompareTo(right) is > 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >=(Uuid7 left, Guid right) {
        return left.CompareTo(right) is > 0 or 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than or equal to right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >=(Guid left, Uuid7 right) {
        return left.CompareTo(right) is > 0 or 0;
    }


    /// <summary>
    /// Returns true if left-hand operand is greater than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >(Uuid7 left, Uuid7 right) {
        return left.CompareTo(right) > 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >(Uuid7 left, Guid right) {
        return left.CompareTo(right) > 0;
    }

    /// <summary>
    /// Returns true if left-hand operand is greater than right-hand operand.
    /// </summary>
    /// <param name="left">Left-hand operand.</param>
    /// <param name="right">Right-hand operand.</param>
    public static bool operator >(Guid left, Uuid7 right) {
        return left.CompareTo(right) > 0;
    }


    /// <summary>
    /// Returns Uuid7 from given Guid.
    /// </summary>
    /// <param name="value">Value.</param>
    public static Uuid7 FromGuid(Guid value) {
        return new Uuid7(value, bigEndian: IsBigEndian);
    }

    /// <summary>
    /// Returns an Uuid7 from given Guid.
    /// </summary>
    /// <param name="value">Value.</param>
    /// <param name="bigEndian">If true, input will be assumed to be in a big-endian format.</param>
    public static Uuid7 FromGuid(Guid value, bool bigEndian) {
        var bytes = value.ToByteArray();
        if (IsBigEndian == bigEndian) { ReverseGuidEndianess(ref bytes); }
        return new Uuid7(bytes);
    }

    /// <summary>
    /// Returns an Uuid7 from given Guid.
    /// </summary>
    /// <param name="value">Value.</param>
    public static implicit operator Uuid7(Guid value) {
        return FromGuid(value);
    }

    /// <summary>
    /// Returns an Guid from given Uuid7.
    /// </summary>
    /// <param name="value">Value.</param>
    public static Guid ToGuid(Uuid7 value) {
        if (value.Bytes == null) { return Guid.Empty; }
#if NET8_0_OR_GREATER
        return new Guid(value.Bytes, true);
#else
        var bytes = new byte[16];
        Buffer.BlockCopy(value.Bytes, 0, bytes, 0, 16);
        if (BitConverter.IsLittleEndian) { ReverseGuidEndianess(ref bytes); }
        return new Guid(bytes);
#endif
    }

    /// <summary>
    /// Returns an Guid from given Uuid7.
    /// </summary>
    /// <param name="value">Value.</param>
    /// <param name="bigEndian">If true, input will be assumed to be in a big-endian format.</param>
    public static Guid ToGuid(Uuid7 value, bool bigEndian) {
        if (value.Bytes == null) { return Guid.Empty; }
#if NET8_0_OR_GREATER
        return new Guid(value.Bytes, bigEndian);
#else
        var bytes = new byte[16];
        Buffer.BlockCopy(value.Bytes, 0, bytes, 0, 16);
        if (IsBigEndian != bigEndian) { ReverseGuidEndianess(ref bytes); }
        return new Guid(bytes);
#endif
    }

    /// <summary>
    /// Returns UUID7 from given Guid.
    /// </summary>
    /// <param name="value">Value.</param>
    public static implicit operator Guid(Uuid7 value) {
        return ToGuid(value);
    }

    #endregion Operators


    #region IComparable<Guid>

    /// <summary>
    /// Compares this instance to a specified Guid object and returns an indication of their relative values.
    /// A negative integer if this instance is less than value; a positive integer if this instance is greater than value; or zero if this instance is equal to value.
    /// </summary>
    /// <param name="other">An object to compare to this instance.</param>
    public int CompareTo(Guid other) {
        var guidBytes = other.ToByteArray();
        if (BitConverter.IsLittleEndian) { ReverseGuidEndianess(ref guidBytes); }
        return CompareArrays(Bytes, guidBytes);
    }

    #endregion IComparable<Guid>


    #region IComparable<Uuid>

    /// <summary>
    /// Compares this instance to a specified Guid object and returns an indication of their relative values.
    /// A negative integer if this instance is less than value; a positive integer if this instance is greater than value; or zero if this instance is equal to value.
    /// </summary>
    /// <param name="other">An object to compare to this instance.</param>
    public int CompareTo(Uuid7 other) {
        return CompareArrays(Bytes, other.Bytes);
    }

    #endregion IComparable<Uuid>


    #region IEquatable<Guid>

    /// <summary>
    /// Returns a value that indicates whether this instance is equal to a specified object.
    /// </summary>
    /// <param name="other">An object to compare to this instance.</param>
    public bool Equals(Guid other) {
#if NET7_0_OR_GREATER
        if (Vector128.IsHardwareAccelerated) {
            var vector1 = (Bytes != null)
                ? Unsafe.ReadUnaligned<Vector128<byte>>(ref Bytes[0])
                : Vector128<byte>.Zero;
            var vector2 = Unsafe.ReadUnaligned<Vector128<byte>>(ref other.ToByteArray()[0]);
            return vector1 == vector2;
        }
#endif
        return CompareArrays(Bytes, other.ToByteArray()) == 0;
    }

    #endregion IEquatable<Guid>


    #region IEquatable<Uuid>

    /// <summary>
    /// Returns a value that indicates whether this instance is equal to a specified object.
    /// </summary>
    /// <param name="other">An object to compare to this instance.</param>
    public bool Equals(Uuid7 other) {
#if NET7_0_OR_GREATER
        if (Vector128.IsHardwareAccelerated) {
            var vector1 = (Bytes != null)
                ? Unsafe.ReadUnaligned<Vector128<byte>>(ref Bytes[0])
                : Vector128<byte>.Zero;
            if (other.Bytes == null) {
                return vector1 == Vector128<byte>.Zero;
            } else {
                var vector2 = Unsafe.ReadUnaligned<Vector128<byte>>(ref other.Bytes[0]);
                return vector1 == vector2;
            }
        }
#endif
        return CompareArrays(Bytes, other.Bytes) == 0;
    }

    #endregion IEquatable<Uuid>


    #region IFormattable

    /// <summary>
    /// Formats the value of the current instance using the specified format.
    /// The following format specifiers are supported:
    /// - D: Default - 32 digits separated by hyphens, e.g. 00000000-0000-0000-0000-000000000000
    /// - N: No hyphen - 32 digits, e.g. 00000000000000000000000000000000
    /// - B: Braces - 	32 digits separated by hyphens, enclosed in braces, e.g. {00000000-0000-0000-0000-000000000000}
    /// - P: Parentheses - 32 digits separated by hyphens, enclosed in parentheses, e.g. (00000000-0000-0000-0000-000000000000)
    /// - X: Hexadecimal - Four hexadecimal values enclosed in braces, where the fourth value is a subset of eight hexadecimal values that is also enclosed in braces, e.g. {0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} - for the love of all that is holy do not use this format
    /// - 5: Id25 - 25 characters from a case-insensitive 35 character alphabet, e.g. 0000000000000000000000000
    /// - 2: Id22 - 22 characters from a 58 character alphabet, e.g. 0000000000000000000000
    /// </summary>
    /// <param name="format">The format to use.</param>
#if NET7_0_OR_GREATER
    public string ToString([StringSyntax(StringSyntaxAttribute.GuidFormat)] string? format) {
#else
    public string ToString(string? format) {
#endif
        return ToString(format, formatProvider: null);
    }

    /// <summary>
    /// Formats the value of the current instance using the specified format.
    /// The following format specifiers are supported:
    /// - D: Default - 32 digits separated by hyphens, e.g. 00000000-0000-0000-0000-000000000000
    /// - N: No hyphen - 32 digits, e.g. 00000000000000000000000000000000
    /// - B: Braces - 	32 digits separated by hyphens, enclosed in braces, e.g. {00000000-0000-0000-0000-000000000000}
    /// - P: Parentheses - 32 digits separated by hyphens, enclosed in parentheses, e.g. (00000000-0000-0000-0000-000000000000)
    /// - X: Hexadecimal - Four hexadecimal values enclosed in braces, where the fourth value is a subset of eight hexadecimal values that is also enclosed in braces, e.g. {0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} - for the love of all that is holy do not use this format
    /// - 5: Id25 - 25 characters from a case-insensitive 35 character alphabet, e.g. 0000000000000000000000000
    /// - 2: Id22 - 22 characters from a 58 character alphabet, e.g. 0000000000000000000000
    /// </summary>
    /// <param name="format">The format to use.</param>
    /// <param name="formatProvider">Not used.</param>
#if NET7_0_OR_GREATER
    public string ToString([StringSyntax(StringSyntaxAttribute.GuidFormat)] string? format, IFormatProvider? formatProvider) {
#else
    public string ToString(string? format, IFormatProvider? formatProvider) {  // formatProvider is ignored
#endif
        switch (format) {  // treat uppercase and lowercase the same (compatibility with Guid ToFormat)
            case null:
            case "":
            case "D":
            case "d": {
#if NET6_0_OR_GREATER
                    return string.Create(36, Bytes, static (destination, bytes)
                        => TryWriteAsDefaultString(destination, bytes, out _));
#else
                    var destination = new char[36];
                    TryWriteAsDefaultString(destination, Bytes, out _);
                    return new string(destination);
#endif
                }

            case "N":
            case "n": {
#if NET6_0_OR_GREATER
                    return string.Create(32, Bytes, static (destination, bytes)
                        => TryWriteAsNoHypensString(destination, bytes, out _));
#else
                    var destination = new char[32];
                    TryWriteAsNoHypensString(destination, Bytes, out _);
                    return new string(destination);
#endif
                }

            case "B":
            case "b": {
#if NET6_0_OR_GREATER
                    return string.Create(38, Bytes, static (destination, bytes)
                        => TryWriteAsBracesString(destination, bytes, out _));
#else
                    var destination = new char[38];
                    TryWriteAsBracesString(destination, Bytes, out _);
                    return new string(destination);
#endif
                }

            case "P":
            case "p": {
#if NET6_0_OR_GREATER
                    return string.Create(38, Bytes, static (destination, bytes)
                        => TryWriteAsParenthesesString(destination, bytes, out _));
#else
                    var destination = new char[38];
                    TryWriteAsParenthesesString(destination, Bytes, out _);
                    return new string(destination);
#endif
                }

            case "X":
            case "x": {
#if NET6_0_OR_GREATER
                    return string.Create(68, Bytes, static (destination, bytes)
                        => TryWriteAsHexadecimalString(destination, bytes, out _));
#else
                    var destination = new char[68];
                    TryWriteAsHexadecimalString(destination, Bytes, out _);
                    return new string(destination);
#endif
                }

            case "6": {  // non-standard (Id26C)
#if NET6_0_OR_GREATER
                    return string.Create(26, Bytes, static (destination, bytes)
                        => TryWriteAsId26(destination, bytes, out _));
#else
                    var destination = new char[26];
                    TryWriteAsId26(destination, Bytes, out _);
                    return new string(destination);
#endif
                }

            case "5": {  // non-standard (Id25)
#if NET6_0_OR_GREATER
                    return string.Create(25, Bytes, static (destination, bytes)
                        => TryWriteAsId25(destination, bytes, out _));
#else
                    var destination = new char[25];
                    TryWriteAsId25(destination, Bytes, out _);
                    return new string(destination);
#endif
                }

            case "2": {  // non-standard (Id22)
#if NET6_0_OR_GREATER
                    return string.Create(22, Bytes, static (destination, bytes)
                        => TryWriteAsId22(destination, bytes, out _));
#else
                    var destination = new char[22];
                    TryWriteAsId22(destination, Bytes, out _);
                    return new string(destination);
#endif
                }

            default: throw new FormatException("Invalid UUID format.");
        }
    }

    #endregion IFormattable


    #region ISpanFormattable

#if NET7_0_OR_GREATER
    /// <summary>
    /// Tries to format the current instance into the provided character span.
    /// </summary>
    /// <param name="destination">The span in which to write.</param>
    /// <param name="charsWritten">When this method returns, contains the number of characters written into the span.</param>
    /// <param name="format">A read-only span containing the character representing one of the following specifiers that indicates the exact format to use when interpreting input: "N", "D", "B", "P", or "X".</param>
    /// <param name="provider">Not used.</param>
    /// <exception cref="NotImplementedException"></exception>
    public bool TryFormat(Span<char> destination, out int charsWritten, [StringSyntax(StringSyntaxAttribute.GuidFormat)] ReadOnlySpan<char> format, IFormatProvider? provider) {  // formatProvider is ignored
        if (format.Length > 1) { charsWritten = 0; return false; }

        var formatChar = (format.Length == 1) ? format[0] : 'D';
        return formatChar switch {  // treat uppercase and lowercase the same (compatibility with Guid ToFormat)
            'D' or 'd' => TryWriteAsDefaultString(destination, Bytes, out charsWritten),
            'N' or 'n' => TryWriteAsNoHypensString(destination, Bytes, out charsWritten),
            'B' or 'b' => TryWriteAsBracesString(destination, Bytes, out charsWritten),
            'P' or 'p' => TryWriteAsParenthesesString(destination, Bytes, out charsWritten),
            'X' or 'x' => TryWriteAsHexadecimalString(destination, Bytes, out charsWritten),
            '6' => TryWriteAsId26(destination, Bytes, out charsWritten),
            '5' => TryWriteAsId25(destination, Bytes, out charsWritten),
            '2' => TryWriteAsId22(destination, Bytes, out charsWritten),
            _ => throw new FormatException("Invalid UUID format."),
        };
    }
#elif NET6_0_OR_GREATER
    /// <summary>
    /// Tries to format the current instance into the provided character span.
    /// </summary>
    /// <param name="destination">The span in which to write.</param>
    /// <param name="charsWritten">When this method returns, contains the number of characters written into the span.</param>
    /// <param name="format">A read-only span containing the character representing one of the following specifiers that indicates the exact format to use when interpreting input: "N", "D", "B", "P", or "X".</param>
    /// <param name="provider">Not used.</param>
    /// <exception cref="NotImplementedException"></exception>
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider) {  // formatProvider is ignored
        if (format.Length > 1) { charsWritten = 0; return false; }

        var formatChar = (format.Length == 1) ? format[0] : 'D';
        return formatChar switch {  // treat uppercase and lowercase the same (compatibility with Guid ToFormat)
            'D' or 'd' => TryWriteAsDefaultString(destination, Bytes, out charsWritten),
            'N' or 'n' => TryWriteAsNoHypensString(destination, Bytes, out charsWritten),
            'B' or 'b' => TryWriteAsBracesString(destination, Bytes, out charsWritten),
            'P' or 'p' => TryWriteAsParenthesesString(destination, Bytes, out charsWritten),
            'X' or 'x' => TryWriteAsHexadecimalString(destination, Bytes, out charsWritten),
            '6' => TryWriteAsId26(destination, Bytes, out charsWritten),
            '5' => TryWriteAsId25(destination, Bytes, out charsWritten),
            '2' => TryWriteAsId22(destination, Bytes, out charsWritten),
            _ => throw new FormatException("Invalid UUID format."),
        };
    }
#endif

    #endregion ISpanFormattable


    #region ISpanParsable<Uuid7>

    /// <summary>
    /// Returns UUID parsed from a given input.
    /// The following formats are supported: D, N, B, and P.
    /// </summary>
    /// <param name="s">Input.</param>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
    public static Uuid7 Parse(string s) {
        return Parse(s, provider: null);
    }

    /// <summary>
    /// Returns true if UUID was successfully parsed.
    /// The following formats are supported: D, N, B, and P.
    /// </summary>
    /// <param name="s">Input.</param>
    /// <param name="result">When this method returns, contains the result of successfully parsing or an undefined value on failure.</param>
#if NET6_0_OR_GREATER
    public static bool TryParse([NotNullWhen(true)] string? s, [MaybeNullWhen(false)] out Uuid7 result) {
#else
    public static bool TryParse(string? s, out Uuid7 result) {
#endif
        return TryParse(s, provider: null, out result);
    }

#if NET7_0_OR_GREATER

    /// <summary>
    /// Returns UUID parsed from a given input.
    /// </summary>
    /// <param name="s">Input.</param>
    /// <param name="provider">Not used.</param>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
    public static Uuid7 Parse(ReadOnlySpan<char> s, IFormatProvider? provider) {
        if (TryParse(s, provider, out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }

    /// <summary>
    /// Returns true if UUID was successfully parsed.
    /// </summary>
    /// <param name="s">Input.</param>
    /// <param name="provider">Not used.</param>
    /// <param name="result">When this method returns, contains the result of successfully parsing or an undefined value on failure.</param>
    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, [MaybeNullWhen(false)] out Uuid7 result) {
        return TryParseAsString(s, out result);
    }
#endif

    /// <summary>
    /// Returns UUID parsed from a given input.
    /// </summary>
    /// <param name="s">Input.</param>
    /// <param name="provider">Not used.</param>
    /// <exception cref="ArgumentNullException">Input cannot be null.</exception>
    /// <exception cref="FormatException">Unrecognized UUID format.</exception>
    public static Uuid7 Parse(string s, IFormatProvider? provider) {
        if (s is null) { throw new ArgumentNullException(nameof(s), "Input cannot be null."); }
        if (TryParse(s, provider, out var result)) {
            return result;
        } else {
            throw new FormatException("Unrecognized UUID format.");
        }
    }

    /// <summary>
    /// Returns true if UUID was successfully parsed.
    /// </summary>
    /// <param name="s">Input.</param>
    /// <param name="provider">Not used.</param>
    /// <param name="result">When this method returns, contains the result of successfully parsing or an undefined value on failure.</param>
#pragma warning disable IDE0060  // Remove unused parameter
#if NET6_0_OR_GREATER
    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out Uuid7 result) {
        if (s == null) { result = Empty; return false; }
        return TryParseAsString(s.AsSpan(), out result);
    }
#else
    public static bool TryParse(string? s, IFormatProvider? provider, out Uuid7 result) {
        if (s == null) { result = Empty; return false; }
        return TryParseAsString(s.ToCharArray(), out result);
    }
#endif
#pragma warning restore IDE0060  // Remove unused parameter

    #endregion ISpanParsable<Uuid7>

}
